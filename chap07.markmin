
## フォームとバリデータ

web2pyでフォームを構築するには以下の4通りの方法があります：
There are four distinct ways to build forms in web2py:
- ``FORM`` はHTMLヘルパに関して低レベルの実装を提供します。``FORM``オブジェクトはHTMLへとシリアライズすることができ、そこに含まれるフィールドについて把握しています。``FORM``オブジェクトは送信フォームの値を検証することができます。
- ``FORM`` provides a low-level implementation in terms of HTML helpers. A ``FORM`` object can be serialized into HTML and is aware of the fields it contains. A ``FORM`` object knows how to validate submitted form values.
- ``SQLFORM`` は、作成、更新、削除のフォームを、既存のデータベーステーブルから構築するための高レベルのAPIを提供します。
- ``SQLFORM`` provides a high-level API for building create, update and delete forms from an existing database table.
-``SQLFORM.factory``は``SQLFORM``の上にある抽象化レイヤです。データベースが用意されてない場合でもフォーム生成機能を活用できるようにしています。これは、テーブルの記述から``SQLFORM``ととても良く似たフォームを生成します。ただしデータベース・テーブルを作成する必要はありません。
- ``SQLFORM.factory`` is an abstraction layer on top of ``SQLFORM`` in order to take advantage of the form generation features even if there is no database present. It generates a form very similar to ``SQLFORM`` from the description of a table but without the need to create the database table.
- ``CRUD``メソッド。SQLFORMと同等でSQLFORMに基づく関数が用意されていますが、よりコンパクトな表記が可能になります。
- ``CRUD`` methods. These are functionally equivalent to SQLFORM and are based on SQLFORM, but provide a more compact notation.

これらすべてのフォームは自分自身を把握しており、入力が検証を通らなかった場合、自分自身を修正してエラーメッセージを加えることができます。フォームでは、検証によって生成された検証済み変数とエラーメッセージを問い合わせることができます。
All these forms are self-aware and, if the input does not pass validation, they can modify themselves and add error messages. The forms can be queried for the validated variables and for error messages that have been generated by validation.

ヘルパを用いて、任意のHTMLコードをフォームへ挿入、また、フォームから抽出することができます。
Arbitrary HTML code can be inserted into or extracted from the form using helpers.

``FORM``と``SQLFORM``はヘルパで``DIV``のように扱えます。例えば、フォームスタイルを指定できます：
``FORM`` and ``SQLFORM`` are helpers and they can be manipulated in as similar way as the ``DIV``. For example you can set a form style:

``
form = SQLFORM(..)
form['_style']='border:1px solid black'
``:code

### ``FORM``
``form``:inxx ``accepts``:inxx ``formname``:inxx

次のような"default.py"コントローラを持つ**test**アプリケーションを考えます：
Consider as an example a **test** application with the following "default.py" controller:
``
def display_form():
    return dict()
``:code

関連付けるビュー"default/display_form.html"は以下のようにします：
and the associated "default/display_form.html" view:
``
{{extend 'layout.html'}}
<h2>Input form</h2>
<form enctype="multipart/form-data"
      action="{{=URL()}}" method="post">
Your name:
<input name="name" />
<input type="submit" />
</form>
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

これは、ユーザー名を問い合わせる一般的なHTMLフォームです。このフォームを入力しサブミット・ボタンをクリックすると、フォームは自分自身をサブミットし、``request.vars.name``変数とその値が下部に表示されます。
This is a regular HTML form that asks for the user's name. When you fill the form and click the submit button, the form self-submits, and the variable ``request.vars.name`` and its value is displayed at the bottom.

同じフォームをヘルパを用いて生成することができます。これは、ビュー、または、アクションにおいて行うことができます。web2pyはフォームの処理をアクションにおいて行うので、フォームをアクションで定義しても差し支えありません。
You can generate the same form using helpers. This can be done in the view or in the action. Since web2py processed the form in the action, it is OK to define the form in the action.

これが新しいコントローラです：
Here is the new controller:
``
def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)
``:code

関連付けるビュー"default/desplay_form.html"は以下のようにします：
and the associated "default/display_form.html" view:
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
``:code

以前のコードは上のコードと等しいです。しかし、フォームは、``FORM``オブジェクトをシリアライズする``{{=form}}``という文によって生成されています。
The code so far is equivalent to the previous code, but the form is generated by the statement ``{{=form}}`` which serializes the ``FORM`` object.

次に、フォームの検証と処理を追加して、一段複雑なものを加えます。
Now we add one level of complexity by adding form validation and processing.

コントローラを以下のように変更します：
Change the controller as follows:
``
def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request,session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)
``:code

関連付けるビュー"default/desplay_form.html"は以下のようにします：
and the associated "default/display_form.html" view:
``
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
<h2>Accepted variables</h2>
{{=BEAUTIFY(form.vars)}}
<h2>Errors in form</h2>
{{=BEAUTIFY(form.errors)}}
``:code

以下のことに注意してください：
Notice that:
- アクションでは、入力フィールド"name"に対して``requires=IS_NOT_EMPTY()``バリデータを加えています。
- In the action, we added the ``requires=IS_NOT_EMPTY()`` validator for the input field "name".
- アクションでは、``form.accepts(...)``の呼び出しを加えています。
- In the action, we added a call to ``form.accepts(..)``
- ビューでは、フォームと``request.vars``とともに``form.vars``と``form.errors``を表示しています。
- In the view, we are printing ``form.vars`` and ``form.errors`` as well as the form and ``request.vars``.

すべての作業は、``form``オブジェクトの``accepts``メソッドによって行われます。これは、``request.vars``を、(バリデータによって表現された)宣言された要求に従って、フィルタします。``accepts``は、検証を通ったこれらの変数を``form.vars``に格納します。フィールドの値が何かしら要求を満たさない場合は、失敗したバリデータがエラーを返し、そのエラーが``form.errors``に格納されます。``form.vars``と``form.errors``は両方とも、``request.vars``に似た``gluon.storage.Storage``オブジェクトです。前者は、次のように検証を通った値を保持します：
All the work is done by the ``accepts`` method of the ``form`` object. It filters the ``request.vars`` according to the declared requirements (expressed by validators). ``accepts`` stores those variables that pass validation into ``form.vars``. If a field value does not meet a requirement, the failing validator returns an error and the error is stored in ``form.errors``. Both ``form.vars`` and ``form.errors`` are ``gluon.storage.Storage`` objects similar to ``request.vars``. The former contains the values that passed validation, for example:
``
form.vars.name = "Max"
``:code

後者は、次のようにエラーを保持します：
The latter contains the errors, for example:
``
form.errors.name = "Cannot be empty!"
``:code

``accepts``メソッドのすべての用法は以下の通りです：
The full signature of the ``accepts`` method is the following:
``onvalidation``:inxx
``
form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):
``:code

これらオプション・パラメータの意味は、次の小節で説明します。
The meaning of the optional parameters is explained in the next sub-sections.

最初の引数には``request.vars``、``request.get_vars``、``request.post_vars``や、単に``request``と指定できます。後者は``request.post_vars``と入力したのと等しく処理されます。
The first argument can be ``request.vars`` or ``request.get_vars`` or ``request.post_vars`` or simply ``request``. The latter is equivalent to accepting as input the ``request.post_vars``.

``accepts``関数はフォームが受理されたときに``True``を返し、そうでない場合は``False``を返します。フォームは、エラーがある場合か、サブミットされてない場合(たとえば、最初に表示されるとき)には受理されません。
The ``accepts``  function returns ``True`` if the form is accepted and ``False`` otherwise. A form is not accepted if it has errors or when it has not been submitted (for example, the first time it is shown).

次に示すのは、このページが最初に表示されたときの様子です：
Here is how this page looks the first time it is displayed:

[[image @:image/en5800.png center 300px]]

無効なサブミットをしたときの様子です：
Here is how it looks upon invalid submission:

[[image @:image/en5900.png center 300px]]

有効なサブミットをしたときの様子です：
Here is how it looks upon a valid submission:

[[image @:image/en6000.png center 300px]]

#### ``process``と``validate``メソッド

以下のショートカットは
A shortcut for
``
form.accepts(request.post_vars,session,...)
``:code
このようになります
is
``
form.process(...).accepted
``:code
後者は``request``と``session``引数を必要としません（任意で指定は可能ですが）。またフォーム自身を返すため、``accepts``とは異なります。内部的には、``process``がacceptsを呼び出し、その引数を渡します。acceptsによって返された値が``form.accepted``に保存されます。
the latter does not need the ``request`` and ``session`` arguments (although you can specify them optionally). it also differs from ``accepts`` because it returns the form itself. Internally ``process`` calls accepts and passes its arguments to it. The value returned by accepts is stored in ``form.accepted``.

process関数は``accepts``に存在しない追加の引数を受け取れます。
The process function takes some extra argument that ``accepts`` does not take:
- ``message_onsuccess``
- ``message_onsuccess``
- ``onsuccess``: 'flash' (既定)に相当し、フォームが受理されると上記の`message_onsuccess``を表示します。
- ``onsuccess``: if equal to 'flash' (default) and the form is accepted it will flash the above `message_onsuccess``
- ``message_onfailure``
- ``message_onfailure``
- ``onfailure``: 'flash' (既定)に相当し、 フォームが検証を通らなかった場合、上記の`message_onfailure``を表示します。
- ``onfailure``: if equal to 'flash' (default) and the form fails validation, it will flash the above `message_onfailure``
- ``next`` フォームが受理されるとユーザーはリダイレクトされます。
- ``next`` the user to redirect after the form is accepted.
``onsuccess``と``onfailure`` には``lambda form: do_something(form)``のような関数も使用できます。
``onsuccess`` and ``onfailure`` can be functions like ``lambda form: do_something(form)``.

``
form.validate(...)
``:code

は以下のショートカットです。

``
form.process(...,dbio=False).accepted
``:code

#### 隠しフィールド

上記のフォーム・オブジェクトが``{{=form}}``によってシリアライズされたとき、``accepts``メソッドに対する前述の呼び出しがあるために、フォームは次のようになります：
When the above form object is serialized by ``{{=form}}``, and because of the previous call to the ``accepts`` method, it now looks like this:
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input name="name" />
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

注意する点は、2つの隠しフィールド"_formkey"と"_formname"があることです。これらの存在は、``accepts``の呼び出しによって引き起こされたもので、2つの異なる重要な役割を果たします：
Notice the presence of two hidden fields: "_formkey" and "_formname". Their presence is triggered by the call to ``accepts`` and they play two different and important roles:
- "_formkey"という隠しフィールドは一度限りのトークンで、web2pyがフォームの二重投稿を防ぐために用いられます。このキーの値はフォームがシリアライズされたときに生成され、``session``に保存されます。フォームがサブミットされたときに、この値が一致する必要があります。そうでないと``accepts``は、フォームが全くサブミットされてないかのように、エラーなしで``False``を返します。これは、フォームが正しくサブミットされたかどうかをweb2pyが判断できないためです。
- The hidden field called "_formkey" is a one-time token that web2py uses to prevent double submission of forms. The value of this key is generated when the form is serialized and stored in the ``session``. When the form is submitted this value must match, or else ``accepts`` returns ``False`` without errors as if the form was not submitted at all. This is because web2py cannot determine whether the form was submitted correctly.
- "_formname"という隠しフィールドは、フォームの名前としてweb2pyによって生成されますが、その名前は上書きすることができます。このフィールドは、ページが複数のフォームを含んで処理することを可能にするために必要です。web2pyは、この名前によって異なるサブミットされたフォームを区別します。
- The hidden field called "_formname" is generated by web2py as a name for the form, but the name can be overridden. This field is necessary to allow pages that contain and process multiple forms. web2py distinguishes the different submitted forms by their names.
- オプション的な隠しフィールドは``FORM(..,hidden=dict(...))``のように指定します。
- Optional hidden fields specified as ``FORM(..,hidden=dict(...))``.

これらの隠しフィールドの役割と、カスタムフォームと複数のフォームを持つページにおける使用方法は、本章の後半で詳しく説明します。
The role of these hidden fields and their usage in custom forms and pages with multiple forms is discussed in more detail later in the chapter.

上記のフォームを空の"name"フィールドでサブミットした場合、フォームは検証を通過しません。フォームが再びシリアライズされるときは、次のように表示されます：
If the form above is submitted with an empty "name" field, the form does not pass validation. When the form is serialized again it appears as:
``
<form enctype="multipart/form-data" action="" method="post">
your name:
<input value="" name="name" />
<div class="error">cannot be empty!</div>
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
``:code

シリアライズしたフォームにあるDIVのクラス"error"の存在に注意してください。web2pyはこのエラーメッセージをフォームに挿入し、検証を通過しなかったフィールドについて訪問者に知らせます。サブミットの際の``accepts``メソッドは、フォームがサブミットされたかどうかを判断し、フィールド"name"が空でないか、また、それが要求されているかをチェックし、最終的に、バリデータからフォームにエラーメッセージを挿入します。
Notice the presence of a DIV of class "error" in the serialized form. web2py inserts this error message in the form to notify the visitor about the field that did not pass validation. The ``accepts`` method, upon submission, determines that the form is submitted, checks whether the field "name" is empty and whether it is required, and eventually inserts the error message from the validator into the form.

基底の"layout.html"ビューは、DIVクラスの"error"を処理することが想定されています。デフォルトのレイアウトはjQueryのエフェクトを使用して、エラーを可視化し、赤い背景とともにスライドダウンさせます。詳細は第11章を参照してください。
The base "layout.html" view is expected to handle DIVs of class "error". The default layout uses jQuery effects to make errors appear and slide down with a red background. See Chapter 11 for more details.

#### ``keepvalues``

``keepvalues``:inxx

オプション引数``keepvalues``は、フォームが受理され、かつ、リダイレクトがないときに、web2pyに何をするか知らせ、同じフォームが再び表示されるようにします。デフォルトではすべてクリアされます。``keepvalues``が``True``の場合、フォームは前回挿入した値を事前に入力します。これは、複数の似たレコードを繰り返し挿入するために使用することを想定したフォームがあるときに便利です。``dbio``引数が``False``の場合、web2pyは、フォームを受理した後、いかなるDBの挿入/更新も行いません。``hideerror``が``True``でフォームにエラーが含まれている場合、フォームがレンダリングされたときにエラーは表示されません(``form.errors``をどのように表示するかは開発者次第です)。``onvalidation``引数は以下に説明します。
The optional argument ``keepvalues`` tells web2py what to do when a form is accepted and there is no redirection, so the same form is displayed again. By default the form is cleared. If ``keepvalues`` is set to ``True``, the form is pre-populated with the previously inserted values. This is useful when you have a form that is supposed to be used repeatedly to insert multiple similar records. If the ``dbio`` argument is set to ``False``, web2py will not perform any DB insert/update after accepting form. If ``hideerror`` is set to ``True`` and the form contains errors, these will not be displayed when the form is rendered (it will be up to you to display them from ``form.errors`` somehow. The ``onvalidation`` argument is explained below.

#### ``onvalidation``

``onvalidation``引数は``None``もしくは、フォームを受け取り何も返さない関数をとることができます。そのような関数は、検証(が通った)直後に、かつ、それ以外のことが発生する前に呼ばれ、フォームを渡します。この関数の目的は複数あります。これは、たとえば、追加的なフォームのチェックを実行したり、最終的にフォームにエラーを加えたりすることができます。これはまた、いくつかのフィールドの値を、他のフィールドの値に基づいて計算するのに使用することもできます。これを用いて、レコードが作成/更新される前にいくつかのアクション(emailの送信など)を引き起こすことも可能です。
The ``onvalidation`` argument can be ``None`` or can be a function that takes the form and returns nothing. Such a function would be called and passed the form, immediately after validation (if validation passes) and before anything else happens. The purpose of this function is multifold. It can be used, for example, to perform additional checks on the form and eventually add errors to the form. It can also be used to compute the values of some fields based on the values of other fields. It can be used to trigger some action (like sending an email) before a record is created/updated.

以下がその例です。
Here is an example:
``
db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c < 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.process(onvalidation=my_form_processing).accepted:
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)
``:code

#### レコード変更の検知

レコードを編集するためにフォームを入力している際に、わずかですが他のユーザーが同じレコードを同時に変更している可能性があります。そこでレコードを保存する際に競合していないかチェックしたいです。これは以下のように実施できます。
When filling a form to edit a record there is a small probability that another user may concurrently be editing the same record. So when we save the record we want to check for possible conflicts. This can be done:

``
db.define_table('dog',Field('name'))

def edit_dog():
    dog = db.dog(request.args(0)) or redirect(URL('error'))
    form=SQLFORM(db.dog,dog)
    form.process(detect_record_change=True)
    if form.record_changed:
        # do something
    elif form.accepted:
        # do something else
    else:
        # do nothing
    return dict(form=form)
``:code

#### フォームとリダイレクト

フォームを使用する最も一般的な方法は、自己サブミットを介して、サブミットされたフィールドの変数が、フォームを生成したものと同じアクションによって処理されるようにすることです。フォームが一旦受理されれば、現在のページを再び表示することはあまりありません(ここでは説明を単純にするためいくつか行っています)。訪問者を"next"ページへリダイレクトさせるのがより一般的です。
The most common way to use forms is via self-submission, so that the submitted field variables are processed by the same action that generated the form. Once the form is accepted, it is unusual to display the current page again (something we are doing here only to keep things simple). It is more common to redirect the visitor to a "next" page.

ここでは新しいコントローラの例を示します：
Here is the new example controller:
``
def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()
``:code

現在のページの代わりにnextページでflashを設定するために、``session.flash``を``response.flash``の代わりに設定する必要があります。web2pyはリダイレクト後、前者を後者に移します。``session.flash``は``session.forget()``を使用していないことが前提であることに注意してください。
In order to set a flash on the next page instead of the current page you must use ``session.flash`` instead of ``response.flash``. web2py moves the former into the latter after redirection. Note that using ``session.flash`` requires that you do not ``session.forget()``.

#### ページ毎に複数のフォーム

この節の内容は、FORMとSQLFORMオブジェクトどちらにも適用されます。
The content of this section applies to both ``FORM`` and ``SQLFORM`` objects.
ページ毎に複数のフォームを持つことが可能です。しかし、web2pyにそれらを区別できるようにしなければなりません。異なるテーブルの``SQLFORM``によって生成されたものならば、web2pyは異なる名前を自動的にそれらに与えます。それ以外の場合は、異なるフォームの名前を明示的に与えなければなりません。以下がその例です。
It is possible to have multiple forms per page, but you must allow web2py to distinguish them. If these are derived by ``SQLFORM`` from different tables, then web2py gives them different names automatically; otherwise you need to explicitly give them different form names. Here is an example:
``
def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    if form1.process(formname='form_one').accepted:
        response.flash = 'form one accepted'
    if form2.process(formname='form_two').accepted:
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)
``:code

ここに生成された出力を示します：
and here is the output it produces:

[[image @:image/en6100.png center 300px]]

訪問者が空のform1をサブミットした場合、form1のみがエラーを表示します。一方、訪問者が空のform2をサブミットした場合、form2のみがエラーメッセージを表示します。
When the visitor submits an empty form1, only form1 displays an error; if the visitor submits an empty form2, only form2 displays an error message.

#### フォームの共有

この節の内容は、``FORM``と``SQLFORM``オブジェクトどちらにも適用されます。ここで説明することは可能ですが推奨されません。自己サブミットするフォームを持つことがベストプラクティスだからです。しかし、場合によっては、フォームを送受信するアクションが異なるアプリケーションに属していて、選択肢がないことがあります。
The content of this section applies to both ``FORM`` and ``SQLFORM`` objects. What we discuss here is possible but not recommended, since it is always good practice to have forms that self-submit. Sometimes, though, you don't have a choice, because the action that sends the form and the action that receives it belong to different applications.

異なるアクションへサブミットするフォームを生成することは可能です。これは、``FORM``または``SQLFORM``オブジェクトの属性において、処理するアクションのURLを指定することで行われます。例:
It is possible to generate a form that submits to a different action. This is done by specifying the URL of the processing action in the attributes of the ``FORM`` or ``SQLFORM`` object. For example:
``
form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.process(session=None, formname=None).accepted:
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()
``:code

"page_one"と"page_two"は両者とも同じ``form``を利用しているので、同じことの繰り返しを避けるために、そのフォームをすべてのアクションの外側で一度だけ定義していることに注意してください。コントローラの冒頭にある共通のコード部分は、アクションの呼び出しに制御を渡す前に毎回実行されます。
Notice that since both "page_one" and "page_two" use the same ``form``, we have defined it only once by placing it outside of all the actions, in order not to repeat ourselves. The common portion of code at the beginning of a controller gets executed every time before giving control to the called action.

"page_one"は``process``(または、``accepts``）を呼び出さないため、formには名前がなくキーもありません。そのため、``session=None``を渡し、``formname=None``を設定する必要があります。そうでないと、フォームは"page_two"に受け取られたときに検証を行いません。
Since "page_one" does not call ``process`` (nor ``accepts``), the form has no name and no key, so you must pass  ``session=None`` and set ``formname=None`` in ``process``, or the form will not validate when "page_two" receives it.

### ``SQLFORM``

次の段階に進んで、以下のようなアプリケーションのモデルファイルを用意します：
We now move to the next level by providing the application with a model file:
``
db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))
``:code

コントローラを以下のように変更します：
Modify the controller as follows:
``
def display_form():
   form = SQLFORM(db.person)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)
``:code

ビューを変更する必要はありません。
The view does not need to be changed.

コントローラでは、``FORM``を構築する必要はありません。なぜなら、``SQLFORM``は、モデルに定義された``db.person``テーブルからそれを構築するからです。この新しいフォームがシリアライズされると次のように表示されます：
In the new controller, you do not need to build a ``FORM``, since the ``SQLFORM`` constructor built one from the table ``db.person`` defined in the model. This new form, when serialized, appears as:
``
<form enctype="multipart/form-data" action="" method="post">
  <table>
    <tr id="person_name__row">
       <td><label id="person_name__label"
                  for="person_name">Your name: </label></td>
       <td><input type="text" class="string"
                  name="name" value="" id="person_name" /></td>
       <td></td>
    </tr>
    <tr id="submit_record__row">
       <td></td>
       <td><input value="Submit" type="submit" /></td>
       <td></td>
    </tr>
  </table>
  <input value="9038845529" type="hidden" name="_formkey" />
  <input value="person" type="hidden" name="_formname" />
</form>
``:code

この自動的に生成されたフォームは、前述の低レベルのフォームよりも複雑です。第1に、これはテーブルの行を含み、各行は3つのカラムを持っています。最初のカラムはフィールドの名前を保持しています(``db.person``から決定されます)。第2のカラムは入力フィールドを保持します(最終的にエラーメッセージも保持します)。第3のカラムは省略可能で空になっています(``SQLFORM``のコンストラクタにおいてフィールドを用いて入力される可能性があります)。
The automatically generated form is more complex than the previous low-level form. First of all, it contains a table of rows, and each row has three columns. The first column contains the field labels (as determined from the ``db.person``), the second column contains the input fields (and eventually error messages), and the third column is optional and therefore empty (it can be populated with the fields in the ``SQLFORM`` constructor).

フォームのすべてのタグには、テーブルとフィールドの名前に由来する名前が付けられています。これによりCSSとJavaScriptを用いてフォームをカスタマイズするのが容易になります。この機能については、第11章で詳しく説明します。
All tags in the form have names derived from the table and field name. This allows easy customization of the form using CSS and JavaScript. This capability is discussed in more detail in Chapter 11.

ここでより重要なのは、``accepts``メソッドがより多くの仕事をすることです。前回の場合と同様、入力の検証を行いますが、加えて、入力が検証を通ったら、データベースに対して新規レコードの挿入を実行し、``form.vars.id``に新規レコードのユニークな"id"を格納します。
More important is that now the ``accepts`` method does a lot more work for you. As in the previous case, it performs validation of the input, but additionally, if the input passes validation, it also performs a database insert of the new record and stores in ``form.vars.id`` the unique "id" of the new record.

``SQLFORM``オブジェクトはまた、自動的に"upload"フィールドを処理し、アップロードしたファイルを"uploads"フォルダに保存します(競合を避けるため安全にリネームして、ディレクトリ・トラバーサル攻撃を防いだ後に保存します)。そして、(新しい)ファイル名をデータベースの適切なフィールドに保存します。フォームが処理されると、新しいファイル名は``form.vars.fieldname``（つまり、``cgi.FieldStorage``オブジェクトの値を``request.vars.fieldname``に置き換える）で参照可能なので、更新後、簡単にその名前を参照することができます。
A ``SQLFORM`` object also deals automatically with "upload" fields by saving uploaded files in the "uploads" folder (after having them renamed safely to avoid conflicts and prevent directory traversal attacks) and stores their names (their new names) into the appropriate field in the database. After the form has been processed, the new filename is available in ``form.vars.fieldname`` (i.e., it replaces the ``cgi.FieldStorage`` object in ``request.vars.fieldname``), so you can easily reference the new name right after upload.

``SQLFORM``は、"boolean"の値をチェックボックスで、"text"の値をテキストエリアで、限定したセットまたはデータベース内に含まれることを要求された値をドロップボックスで、"upload"フィールドをアップロードしたファイルをダウンロードできるようにしたリンクで、表示します。"blob"フィールドは非表示します。後述しますが、異なる方法で処理されることになるからです。
A ``SQLFORM`` displays "boolean" values with checkboxes, "text" values with textareas, values required to be in a definite set or a database with drop-boxes, and "upload" fields with links that allow users to download the uploaded files. It hides "blob" fields, since they are supposed to be handled differently, as discussed later.

たとえば、次のモデルを考えてください：
For example, consider the following model:
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))
``:code

この場合、``SQLFORM(db.person)``は次に表示されるようなフォームを生成します：
In this case, ``SQLFORM(db.person)`` generates the form shown below:

[[image @:image/en6200.png center 300px]]

``SQLFORM``のコンストラクタは、さまざまなカスタマイズを可能にします。たとえば、フィールドの一部のみを表示したり、ラベルを変更したり、オプション的な第3のカラムに値を加えたり、現在のINSERTフォームとは対照的にUPDATEとDELETEフォームを作成したりすることができます。``SQLFORM``はweb2pyにおいて、最も大きく時間を節約できる単一のオブジェクトです。
The ``SQLFORM`` constructor allows various customizations, such as displaying only a subset of the fields, changing the labels, adding values to the optional third column, or creating UPDATE and DELETE forms, as opposed to INSERT forms like the current one.
``SQLFORM`` is the single biggest time-saver object in web2py.

``SQLFORM``クラスは"gluon/sqlhtml.py"に定義されています。これは、``xml``メソッドをオーバライドして簡単に拡張することができます。このメソッドはこのオブジェクトをシリアライズして、その出力を変更します。
The class ``SQLFORM`` is defined in "gluon/sqlhtml.py". It can be easily extended by overriding its ``xml`` method, the method that serializes the objects, to change its output.

``fields``:inxx ``labels``:inxx
``SQLFORM``のコンストラクタの用法は以下の通りです：
The signature for the ``SQLFORM`` constructor is the following:
``
SQLFORM(table, record = None,
        deletable = False, linkto = None,
        upload = None, fields = None, labels = None,
        col3 = {}, submit_button = 'Submit',
        delete_label = 'Check to delete:',
        showid = True, readonly = False,
        comments = True, keepopts = [],
        ignore_rw = False, record_id = None,
        formstyle = 'table3cols',
	buttons = ['submit'], separator = ': ',
        **attributes)

``:code
- オプション的な第2の引数は、INSERTフォームから、指定したレコードに対するUPDATEフォームに切り替えます(次の小節を参照してください)。``showid``:inxx ``delete_label``:inxx ``id_label``:inxx ``submit_button``:inxx
- The optional second argument turns the INSERT form into an UPDATE form for the specified record (see next subsection). ``showid``:inxx ``delete_label``:inxx ``id_label``:inxx ``submit_button``:inxx
``deletable``が``True``の場合、UPDATEフォームは"Chceck to delete"というチェックボックスを表示します。フィールドがある場合、このラベルの値は``delete_label``引数を介して設定されます。
- If ``deletable`` is set to ``True``, the UPDATE form displays a "Check to delete" checkbox. The value of the label if this field is set via the ``delete_label`` argument.
- ``submit_button``はサブミット・ボタンの値を設定します。
- ``submit_button`` sets the value of the submit button.
- ``id_label``はレコードの"id"のラベルを設定します。
- ``id_label`` sets the label of the record "id"
- ``showid``が``False``の場合、レコードの"id"は表示されません。
- The "id" of the record is not shown if ``showid`` is set to ``False``.
``fields``は表示したいフィールド名のオプション的なリストです。リストが提供されている場合、リスト内のフィールドしか表示されません。例:
- ``fields`` is an optional list of field names that you want to display. If a list is provided, only fields in the list are displayed. For example:
``
fields = ['name']
``:code
-  ``labels``はフィールドラベルの辞書です。辞書のキーはフィールド名で、対応する値はラベルとして表示されるものです。ラベルが提供されていない場合、web2pyはラベルをフィールド名から生成します(フィールド名を大文字で書き始めアンダースコアをスペースに置換します)。例:
- ``labels`` is a dictionary of field labels. The dictionary key is a field name and the corresponding value is what gets displayed as its label. If a label is not provided, web2py derives the label from the field name (it capitalizes the field name and replaces underscores with spaces). For example:
``
labels = {'name':'Your Full Name:'}
``:code
- ``col3``は第3のカラム用の辞書の値です。例:
- ``col3`` is a dictionary of values for the third column. For example:
``
col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}
``:code
- ``linkto``と``upload``は、ユーザー定義コントローラへのオプション的なURLです。これにより、フォームで参照フィールドを扱うことが可能になります。これについては、後述の節で詳説します。
- ``linkto`` and ``upload`` are optional URLs to user-defined controllers that allow the form to deal with reference fields. This is discussed in more detail later in the section.
- ``readonly``。Trueの場合、読み取り専用のフォームを表示します。
- ``readonly``. If set to True, displays the form as readonly
- ``comments``。Falseの場合、col3のコメントを表示しません。
- ``comments``. If set to False, does not display the col3 comments
- ``ignore_rw``。通常は、作成/更新フォームに対して、writable=Trueでマークされたフィールドしか表示されず、読み取り専用フォームに対しては、readable=Trueでマークしたフィールドしか表示されません。``ignore_rw=True``に設定すると、これらの制約は無視され、すべてのフィールドが表示されます。これは主に、appadminインターフェースにおいて、モデルの意図を覆して、各テーブルのすべてのフィールドを表示するために使用されます。
- ``ignore_rw``. Normally, for a create/update form, only fields marked as writable=True are shown, and for readonly forms, only fields marked as readable=True are shown. Setting ``ignore_rw=True`` causes those constraints to be ignored, and all fields are displayed. This is mostly used in the appadmin interface to display all fields for each table, overriding what the model indicates.
- ``formstyle``:inxx ``formstyle``フォームをhtmlにシリアライズするときに使用されるスタイルを決めます。次の値をとることができます："table3cols"(デフォルト)、"table2cols"(一行にラベルとコメントを、もう1つの行に入力を表示します)、"ul"(入力フィールドの順序なしリストを作成します)、"divs"(フォームをcssフレンドリなdivで表現します)。 ``formystyle``はまた、(record_id, field_label, field_widget, field_comment)を属性として受け取り、TR()オブジェクトを返す関数をとることもできます。
- ``formstyle``:inxx ``formstyle`` determines the style to be used when serializing the form in html. It can be "table3cols" (default), "table2cols" (one row for label and comment, and one row for input), "ul" (makes an unordered list of input fields), "divs" (represents the form using css friendly divs, for arbitrary customization). ``formstyle`` can also be a function that takes (record_id, field_label, field_widget, field_comment) as attributes and returns a TR() object.

- ``buttons``:inxx ``buttons``は``INPUT``や``TAG.BUTTON``（技術的にはあらゆるヘルパの組み合わせを使用できるが）のリストで、submitボタンが配置されるDIVに追加されます。
- ``buttons``:inxx is a list of ``INPUT``s or ``TAG.BUTTON``s (though technically could be any combination of helpers) that will be added to a DIV where the submit button would go.
- ``separator``:inxx ``separator``はフォームのラベルと入力フィールドの間に区切り文字を設定します。
- ``separator``:inxx ``separator`` sets the string that separates form labels from form input fields.
- オプション的な``attributes``は、``SQLFORM``オブジェクトをレンダリングする``FORM``タグに対して渡したいアンダースコアで始まる引数群です。たとえば次のようになります：
- Optional ``attributes`` are arguments starting with underscore that you want to pass to the ``FORM`` tag that renders the ``SQLFORM`` object. Examples are:
``
_action = '.'
_method = 'POST'
``:code

特別な``hidden``属性があります。辞書が``hidden``として渡されたとき、その項目は"hidden"INPUTフィールドに変換されます(第5章の``FORM``ヘルパの例を参照してください)。
There is a special ``hidden`` attribute. When a dictionary is passed as ``hidden``, its items are translated into "hidden" INPUT fields (see the example for the ``FORM`` helper in Chapter 5).

``
form = SQLFORM(....,hidden=...)
``:code
隠しフィールドはサブミットによって渡されるため、``form.accepts(...)``は受信した隠しフィールドを読み込み、form.varsに値を渡すといっと動作は行いません。これはセキュリティ上の理由です。隠しフィールドは改ざんされる可能性があるからです。このため、隠しフィールドをrequestからフォームに明示的に移動する必要があります。
causes the hidden fields to be passed  with the submission, no more, no less.
``form.accepts(...)`` is not
intended to read the received hidden fields and move them into
form.vars. The reason is security. hidden fields can be tampered with.
So you have to do explicitly move hidden fields from the request to the form:

``
form.vars.a = request.vars.a
form = SQLFORM(..., hidden=dict(a='b'))
``:code

#### ``SQLFORM``と``insert``/``update``/``delete``
``SQLFORM``はフォームが受理されると新しいレコードを作成します。以下の例を考えてみると、
``form=SQLFORM(db.test)``:code　このとき、最後に作成されたレコードのidは``form.vars.id``で参照できます。
``SQLFORM`` creates a new db record when the form is accepted. Assuming ``form=SQLFORM(db.test)``:code, then the id of the last-created record will be accessible in ``myform.vars.id``.

``delete record``:inxx
レコードを``SQLFORM``コンストラクタのオプション的な第2の引数に渡した場合、フォームはそのレコードに対するUPDATEフォームになります。つまり、フォームがサブミットされると既存のレコードが更新され新しいレコードは挿入されません。``deletable=True``属性を設定して場合は、UPDATEフォームは"Check to delete"というチェックボックスを表示します。チェックされると、レコードは削除されます。
``delete record``:inxx
If you pass a record as the optional second argument to the ``SQLFORM`` constructor, the form becomes an UPDATE form for that record. This means that when the form is submitted the existing record is updated and no new record is inserted. If you set the argument ``deletable=True``, the UPDATE form displays a "check to delete" checkbox. If checked, the record is deleted.

------
フォームがサブミットされ、削除チェックボックスがチェックされている場合は、``form.deleted``属性に``True``が設定されます。
------
------
If a form is submitted and the delete checkbox is checked the attribute
``form.deleted`` is set to ``True``.
------

たとえば、前述の例のコントローラを修正し、次のように、URLのパスにおけて追加の整数引数を渡すことができます。
You can modify the controller of the previous example so that when we pass an additional integer argument in the URL path, as in:
``
/test/default/display_form/2
``:code

これに対応するidを持つレコードがあると、``SQLFORM``は、このレコードのためのUPDATE/DELETEフォームを生成します：
and if there is a record with the corresponding id, the ``SQLFORM`` generates an UPDATE/DELETE form for the record:
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

2行目でレコードを見つけ、3行目でUPDATE/DELETEフォームを作り、4行目はすべての対応するフォームの処理を行います。
Line 2 finds the record and line 3 makes an UPDATE/DELETE form. Line 4 does all the corresponding form processing.

------
更新フォームは作成フォームにとても似ていますが、現在のレコードによって事前入力され、プレビュー画像も表示します。デフォルトでは、``deletable = True``になっていて、"delete record"オプションが更新フォームに表示されます。
An update form is very similar to a create form except that it is pre-populated with the current record and it previews images. By default ``deletable = True`` which means the update form will display a "delete record" option.
------

編集フォームはまた、``name="id"``という隠れINPUTフィールドを保持しています。これによりレコードが特定できるようになります。このidはまた、追加のセキュリティのためサーバーサイドで保存され、訪問者がフィールドの値を改ざんした場合、UPDATEは実行されず、web2pyは"user is tampering with form"となるSyntaxErrorを発生させます。
Edit forms also contain a hidden INPUT field with ``name="id"`` which is used to identify the record. This id is also stored server-side for additional security and, if the visitor tampers with the value of this field, the UPDATE is not performed and web2py raises a SyntaxError, "user is tampering with form".

Fieldが``writable=False``としてマークされていると、フィールドは作成フォームに表示されず、読み込み専用の更新フォームで表示されます。フィールドが``writable=False``、かつ、``readable=False``としてマークされている場合、フィールドは、更新フォームを含むすべてのフォーム上で表示されません。
When a Field is marked with ``writable=False``, the field is not shown in create forms, and it is shown readonly in update forms. If a field is marked as ``writable=False`` and ``readable=False``, then the field is not shown at all, not even in update forms.

次のように作成されたフォームは、
Forms created with
``
form = SQLFORM(...,ignore_rw=True)
``:code

``readable``と``writable``の属性を無視して、常にすべてのフィールドを表示します。``appadmin``のフォームはデフォルトでそれらを無視します。
ignore the ``readable`` and ``writable`` attributes and always show all fields. Forms in ``appadmin`` ignore them by default.

次のように作成されたフォームは、
Forms created with
``
form = SQLFORM(table,record_id,readonly=True)
``:code

常に、読み取り専用モードですべてのフィールドを表示し、フォームが受理することはありません。
always show all fields in readonly mode, and they cannot be accepted.

#### HTMLにおける``SQLFORM``

``SQLFORM``のフォームをその生成と処理機能から利便を享受するために使用したいが、``SQLFORM``オブジェクトのパラメタではできなくらいのHTMLのカスタマイズが必要で、HTMLを用いてフォームを設計しなければならないことがあります。
There are times when you want to use ``SQLFORM`` to benefit from its form generation and processing, but you need a level of customization of the form in HTML that you cannot achieve with the parameters of the ``SQLFORM`` object, so you have to design the form using HTML.

では、前回のコントローラを編集し新しいアクションを追加してみます：
Now, edit the previous controller and add a new action:
``
def display_manual_form():
   form = SQLFORM(db.person)
   if form.process(session=None, formname='test').accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill the form'
   # Note: no form instance is passed to the view
   return dict()
``:code

そして、関連付けられたビュー"default/display_manual_form.html"にフォームを挿入します：
and insert the form in the associated "default/display_manual_form.html" view:
``
{{extend 'layout.html'}}
<form>
<ul>
  <li>Your name is <input name="name" /></li>
</ul>
  <input type="submit" />
  <input type="hidden" name="_formname" value="test" />
</form>
``:code

ここで、アクションはフォームを返していないことに注意してください。なぜならビューに渡す必要がないからです。ビューはHTMLにおいて手動で作成されたフォームを含んでいます。フォームは、隠れフィールド"_formname"を含んでいて、それはアクションの``accepts``の引数で指定されたformnameと必ず同じにしなければなりません。web2pyは同じページに複数のフォームがある場合に、どれからサブミットされたかを判断するのに、フォームの名前を使用します。ページが単一のフォームからなる場合、``formname=None``と設定して、ビューにおける隠れフィールドを見送ることができます。
Notice that the action does not return the form because it does not need to pass it to the view. The view contains a form created manually in HTML. The form contains a hidden field "_formname" that must be the same ``formname`` specified as an argument of ``accepts`` in the action. web2py uses the form name in case there are multiple forms on the same page, to determine which one was submitted. If the page contains a single form, you can set ``formname=None`` and omit the hidden field in the view.

``form.accepts``はデータベーステーブル``db.person``のフィールドに適合するデータを``response.vars``内から検索します。これらのフィールドは以下のようにHTMLで宣言することができます。
``form.accepts`` will look inside ``response.vars`` for data that matches fields in the database table ``db.person``.  These fields are declared in the HTML in the format
``<input name="field_name_goes_here" />
``:code

上記の例では、フォーム変数がURLの引数として渡される点に注意してください。そうしたくない場合、``POST``プロトコルが指定される必要があります。さらに、uploadフィールドが指定された場合は、フォーム上でそれを許可するように設定しなければなりません。両方のオプションを以下に示します。
Note that in the example given, the form variables will be passed on the URL as arguments.  If this is not desired, the ``POST`` protocol will have to be specified.  Note furthermore, that if upload fields are specified, the form will have to be set up to allow this.  Here, both options are shown:
``
<form enctype="multipart/form-data" method="post">
``:code

#### ``SQLFORM``とアップロード

"upload"型のフィールドは特殊です。それらは、``type="file"``のINPUTフィールドでレンダリングされます。特に指定がない限り、アップロードしたファイルはバッファにストリームされ、自動的に割り当てられる新しい安全な名前を用いて、アプリケーションの"upload"フォルダに保存されます。このファイルの名前はこのとき、アップロード型のフィールドに保存されます。
Fields of type "upload" are special. They are rendered as INPUT fields of ``type="file"``. Unless otherwise specified, the uploaded file is streamed in using a buffer, and stored under the "uploads" folder of the application using a new safe name, assigned automatically. The name of this file is then saved into the field of type uploads.

例として、次のモデルを考えてください：
As an example, consider the following model:
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))
``:code

先ほどのコントローラアクション"display_form"と同じものを利用することができます。
You can use the same controller action "display_form" shown above.

新規のレコードを挿入するとき、フォームはファイルに対する閲覧を可能にします。たとえば、jpg画像を選択してください。このファイルはアップロードされ、次のように保存されます：
When you insert a new record, the form allows you to browse for a file.
Choose, for example, a jpg image. The file is uploaded and stored as:
``
applications/test/uploads/person.image.XXXXX.jpg
``:code

"xxxxxx"は、web2pyによってこのファイルに割り当てられるランダムな識別子になります。
"XXXXXX" is a random identifier for the file assigned by web2py.

``content-disposition``:inxx

-------
デフォルトでは、アップロードしたファイルの元のファイル名はb16エンコードされ、そのファイルに対する新しい名前の構築に使用されることに注意してください。この名前は、デフォルトの"download"アクションによって取り出され、元のファイルへのContent-Dispositionヘッダを設定するのに使用されます。
Notice that, by default, the original filename of an uploaded file is b16encoded and used to build the new name for the file. This name is retrieved by the default "download" action and used to set the content disposition header to the original filename.
-------

拡張子だけがそのままになります。これはセキュリティ上の理由です。なぜなら、ファイル名は特別な文字列を含む可能性があり、訪問者にディレクトリ・トラバーサル攻撃や他の悪意のある操作を許してしまうからです。
Only its extension is preserved. This is a security requirement since the filename may contain special characters that could allow a visitor to perform directory traversal attacks or other malicious operations.

新しいファイル名は``form.vars.image``にも格納されます。
The new filename is also stored in ``form.vars.image``.

UPDATEフォームを使用してレコードを編集するとき、既存のアップロードしたファイルへのリンクを表示するのは便利で、web2pyはその方法を提供しています。
When editing the record using an UPDATE form, it would be nice to display a link to the existing uploaded file, and web2py provides a way to do it.

URLをupload引数を介して``SQLFORM``のコンストラクタに渡す場合、web2pyは、ファイルをダウンロードするために、そのURLのアクションを用います。次のアクションを考えてください：
If you pass a URL to the ``SQLFORM`` constructor via the upload argument, web2py uses the action at that URL to download the file. Consider the following actions:
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)
``:code

さて、次のURLにて新規のレコードを挿入してみます：
Now, insert a new record at the URL:
``
http://127.0.0.1:8000/test/default/display_form
``:code

画像をアップロード、フォームをサブミットして、次のURLを訪れて新しく作られたレコードを編集します：
Upload an image, submit the form, and then edit the newly created record
by visiting:
``
http://127.0.0.1:8000/test/default/display_form/3
``:code

(ここでは最新のレコードがid=3をもつと仮定します)。フォームは以下に示すように画像のプレビューを表示します：
(here we assume the latest record has id=3). The form will display an image preview as shown below:

[[image @:image/en6300.png center 300px]]

このフォームは、シリアライズされるときに、次のようなHTMLを生成します：
This form, when serialized, generates the following HTML:
``
<td><label id="person_image__label" for="person_image">Image: </label></td>
<td><div><input type="file" id="person_image" class="upload" name="image"
/>[<a href="/test/default/download/person.image.0246683463831.jpg">file</a>|
<input type="checkbox" name="image__delete" />delete]</div></td><td></td></tr>
<tr id="delete_record__row"><td><label id="delete_record__label" for="delete_record"
>Check to delete:</label></td><td><input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /></td>
``:code

これは、アップロードしたファイルをダウンロードするリンクと、データベースのレコードからこのファイルを削除するためのチェックボックスを含んでいます。したがって、"image"フィールドにはNULLが格納されています。
which contains a link to allow downloading of the uploaded file, and a checkbox to remove the file from the database record, thus storing NULL in the "image" field.

なぜ、このような機構が公開されているのでしょうか？なぜ、ダウンロード関数を書く必要があるのでしょうか？なぜなら、いくつかの認証メカニズムをダウンロード関数に課すことが必要になるかもしれないからです。例は、第9章を参照してください。
Why is this mechanism exposed? Why do you need to write the download function? Because you may want to enforce some authorization mechanism in the download function. See Chapter 9 for an example.

通常アップロードファイルは"app/uploads"の中に保存されますが、別の場所を指定することもできます。
Normally uploaded files are stored into "app/uploads" but you can specify an alternate location:
``
Field('image', 'upload', uploadfolder='...')
``
多くのオペレーティングシステムにおいて、同一のフォルダ内に大量のファイルがある場合はファイルシステムへの接続が遅くなる場合があります。もし1000以上のファイルをアップロードする予定があるならば、web2pyにサブフォルダでアップロードファイルを整理するように指示できます。
In most operating system, accessig the file system can become slow when there are many files in the same folder. If you plan to upload more than 1000 files you can ask web2py to organize the uploads in subfolders:
``
Field('image', 'upload', uploadseparate=True)
``


#### 元のファイル名の保存

web2pyは自動的に元のファイル名を新しいUUIDのファイル名の中に保存し、ファイルがダウンロードされたときにそれを取り出します。ダウンロードの際、オリジナルのファイル名は、HTTPレスポンスのContent-Dispositionヘッダに格納されます。これはすべて、プログラミングの必要なしに透過的に行われます。
web2py automatically stores the original filename inside the new UUID filename and retrieves it when the file is downloaded. Upon download, the original filename is stored in the content-disposition header of the HTTP response. This is all done transparently without the need for programming.

時には、オリジナルのファイル名をデータベースのフィールドに保存したい場合もあります。この場合、モデルを修正し、それを保存するフィールドを加える必要があります：
Occasionally you may want to store the original filename in a database field. In this case, you need to modify the model and add a field to store it in:
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))
``:code

そして、それを処理するようにコントローラーを修正する必要があります：
then you need to modify the controller to handle it:
``
def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image!=None:
        form.vars.image_filename = request.vars.image.filename
    if form.process().accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

``SQLFORM``は"image_filename"フィールドを表示していないことに注意してください。"display_form"アクションは、``request.vars.image``のファイル名を``form.vars.image_filename``に移動します。これにより、``accepts``においてファイル名を処理し、データベースに保存することができるようになります。ダウンロード関数は、そのファイルを配信する前に、元のファイル名をデータベースにおいてチェックし、Content-Dispositionヘッダにおいて使用します。
Notice that the ``SQLFORM`` does not display the "image_filename" field.
The "display_form" action moves the filename of the ``request.vars.image``
into the ``form.vars.image_filename``, so that it gets processed by ``accepts`` and
stored in the database. The download function, before serving the file, checks in the database for the original filename and uses it in the content-disposition header.

#### ``autodelete``
``autodelete``:inxx

レコードを削除する際に、``SQLFORM``はレコードによって参照された物理的なアップロード・ファイルを削除することはありません。その理由は、web2pyがそのファイルが他のテーブルによって使用/リンクされているか、また、他の目的で使用されているかどうか知ることができないからです。対応するレコードが削除されたとき、実際のファイルを削除しても安全だと判断できる場合は、次のようにしてそうすることができます：
The ``SQLFORM``, upon deleting a record, does not delete the physical uploaded file(s) referenced by the record. The reason is that web2py does not know whether the same file is used/linked by other tables or used for other purpose. If you know it is safe to delete the actual file when the corresponding record is deleted, you can do the following:
``
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('file','upload',autodelete=True))
``:code

``autodelete``属性はデフォルトでは``False``です。``True``に設定すると、レコードが削除されるとき、ファイルも削除されるようになります。
The ``autodelete`` attribute is ``False`` by default. When set to ``True`` is makes sure the file is deleted when the record is deleted.

#### 参照レコードへのリンク

今度は、参照フィールドによってリンクされた2つのテーブルを考えます。
Now consider the case of two tables linked by a reference field. For example:
``
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', db.person),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db,db.person.id,'%(name)s')
``:code

飼い主は犬を飼い、犬は所有者(owner)、つまり、飼い主に所属しています。犬の所有者(owner)には、有効な``db.person.id``を``'%(name)s'``を用いて参照することが要求されます。
A person has dogs, and each dog belongs to an owner, which is a person. The dog owner is required to reference a valid ``db.person.id`` by ``'%(name)s'``.

このアプリケーションの**appdadmin**インターフェースを用いて、何人かの飼い主と彼らの犬を加えましょう。
Let's use the **appadmin** interface for this application to add a
few persons and their dogs.

既存の飼い主を編集するとき、**appadmin**のUPDATEフォームは、この飼い主に属する犬の一覧を表示するページへのリンクを表示します。この挙動は、``SQLFORM``の``linkto``引数を用いて真似することができます。``linkto``は、``SQLFORM``からのクエリ文字列を受け取って対応するレコードを返す新規のアクションのURLを指す必要があります。以下がその例です。
When editing an existing person, the **appadmin** UPDATE form shows a link to a page that lists the dogs that belong to the person. This behavior can be replicated using the ``linkto`` argument of the ``SQLFORM``. ``linkto`` has to point to the URL of a new action that receives a query string from the ``SQLFORM`` and lists the corresponding records.
Here is an example:
``
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   url = URL('download')
   link = URL('list_records', args='db')
   form = SQLFORM(db.person, record, deletable=True,
                  upload=url, linkto=link)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
``:code

これがそのページです：
Here is the page:

[[image @:image/en6400.png center 300px]]

"dog.owner"というリンクがあります。このリンクの名前は、次のような``SQLFORM``の``labels``引数を介して変更することができます：
There is a link called "dog.owner". The name of this link can be changed via the ``labels`` argument of the ``SQLFORM``, for example:
``
labels = {'dog.owner':"This person's dogs"}
``:code

リンクをクリックすると、次の場所に向かいます：
If you click on the link you get directed to:
``
/test/default/list_records/dog?query=dog.owner%3D5
``:code

"list_records"は指定されたアクションで、``request.args(0)``に参照するテーブルの名前が設定され、``request.vars.query``にSQLのクエリ文字列が設定されています。URLのクエリ文字列は適切にurlエンコードされた"dog.owner=5"の値を含んでいます(web2pyはURLを解析するときに自動的にこれをデコードします)。
"list_records" is the specified action, with ``request.args(0)`` set to the name of the referencing table and ``request.vars.query`` set to the SQL query string.
The query string in the URL
contains the value "dog.owner=5" appropriately url-encoded
(web2py decodes this automatically when the URL is parsed).

とても汎用的な"list_records"アクションを次のように簡単に実装することができます：
You can easily implement a very general "list_records" action as follows:
``
def list_records():
    table = request.args(0)
    query = request.vars.query
    records = db(query).select(db[table].ALL)
    return dict(records=records)
``:code

関連付けられるビュー"default/list_records.html"は次のようにします：
with the associated "default/list_records.html" view:
``
{{extend 'layout.html'}}
{{=records}}
``:code

選択によってレコードセットが返され、ビューでシリアライズされるとき、これは最初にSQLTABLEオブジェクト(Tableと同じではありません)に変換された後、各フィールドがテーブルのカラムと対応するHTMLテーブルへとシリアライズされます。
When a set of records is returned by a select and serialized in a view, it is first converted into a SQLTABLE object (not the same as a Table) and then serialized into an HTML table, where each field corresponds to a table column.

#### フォームの事前入力
次の構文を用いて、フォームを事前入力することは常に可能です：
It is always possible to pre-populate a form using the syntax:
``
form.vars.name = 'fieldvalue'
``:code

上記のような文は、フィールド(この例では"name")が明示的にフォームで表示されているかにかかわらず、フォームの宣言の後、かつ、フォームの受理の前に挿入される必要があります。
Statements like the one above must be inserted after the form declaration and before the form is accepted, whether or not the field ("name" in the example) is explicitly visualized in the form.

#### ``SQLFORM``に要素の追加
フォーム作成後に要素を追加したい場合があります。例えば、あなたのウェブサイトの会員規約に同意するかどうかのチェックボックスを追加したい場合です。
Sometimes you may wish to add an extra element to your form after it has been created. For example, you may wish to add a checkbox which confirms the user agrees with the terms and conditions of your website:
``
form = SQLFORM(db.yourtable)
my_extra_element = TR(LABEL('I agree to the terms and conditions'), \
                      INPUT(_name='agree',value=True,_type='checkbox'))
form[0].insert(-1,my_extra_element)
``:code

``my_extra_element``変数はフォームスタイルに適合している必要があります。この例では、デフォルトの``formstyle='table3cols'``を想定しています。
The variable ``my_extra_element`` should be adapted to the formstyle. In this example, the default ``formstyle='table3cols'`` has been assumed.

サブミット後、``form.vars.agree``はチェックボックスのステータス値を持ち、``onvalidation``関数などで使用できます。
After submission, ``form.vars.agree`` will contain the status of the checkbox, which could then be used in an ``onvalidation`` function, for instance.

#### データベースIOなしの``SQLFORM``

``SQLFORM``を使用してデータベーステーブルからフォームを生成し、サブミットしたフォームをそのまま検証するが、データベースにおいて自動的なINSERT/UPDATE/DELTEを行いたくない場合があります。たとえば、1つのフィールドが他の入力フィールドから計算される必要がある場合です。また、挿入されたデータに対して標準の検証では達成できない追加の検証を行いたい場合です。
There are times when you want to generate a form from a database table using ``SQLFORM`` and you want to validate a submitted form accordingly, but you do not want any automatic INSERT/UPDATE/DELETE in the database. This is the case, for example, when one of the fields needs to be computed from the value of other input fields. This is also the case when you need to perform additional validation on the inserted data that cannot be achieved via standard validators.

これは、次のものを：
This can be done easily by breaking:
``
form = SQLFORM(db.person)
if form.process().accepted:
    response.flash = 'record inserted'
``:code

以下のように分解して簡単に行うことができます。
into:
``
form = SQLFORM(db.person)
if form.validate():
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'
``:code

同じことはUPDATE/DELETEフォームでも行うことができます。次のものを：
The same can be done for UPDATE/DELETE forms by breaking:
``
form = SQLFORM(db.person,record)
if form.process().accepted:
    response.flash = 'record updated'
``:code

以下のように分解します。
into:
``
form = SQLFORM(db.person,record)
if form.validate():
    if form.deleted:
        db(db.person.id==record.id).delete()
    else:
        record.update_record(**dict(form.vars))
    response.flash = 'record updated'
``:code

"upload"型フィールドを持つテーブルの場合でも、``process(dbio=False)``と``validate()``はどちらもアップロードファイルの保存とリネームを、``dbio=True``のように、つまりデフォルトのシナリオのように、処理します。
In the case of a table including an "upload"-type field ("fieldname"), both ``process(dbio=False)`` and ``validate()`` deal with the storage of the uploaded file as if ``process(dbio=True)``, the default behavior.

アップロードされたファイル名は以下にあります：
The name assigned by web2py to the uploaded file can be found in:
``
form.vars.fieldname
``:code

### ``SQLFORM.factory``

データベース・テーブルを持っているかのようにフォームを生成したいが、データベース・テーブルはいらないような場面があります。見栄えのよいCSSフレンドリなフォームの生成や、ファイルのアップロードとリネームの実行のために、``SQLFORM``の能力を単純に活用したい場面です。
There are cases when you want to generate forms ''as if'' you had a database table but you do not want the database table. You simply want to take advantage of the ``SQLFORM`` capability to generate a nice looking CSS-friendly form and perhaps perform file upload and renaming.

これは``form_factory``を介して行うことができます。ここに、フォームを生成し、検証を行い、ファイルをアップロードし、すべてを``session``に保存するような例を示します。
This can be done via a ``form_factory``. Here is an example where you generate the form, perform validation, upload a file and store everything in the ``session`` :
``
def form_from_factory():
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.process().accepted:
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.filename = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
``:code

次にビュー"default/form_from_factory.html"を示します：
Here is the "default/form_from_factory.html" view:
``
{{extend 'layout.html'}}
{{=form}}
``:code

フィールドのラベルにおいてスペースの代わりにアンダースコアを使用するか、``SQLFORM``で行ったのと同様に、``labels``の辞書を``form_factory``に明示的に渡す必要があります。デフォルトでは、``SQLFORM.factory``は、あたかも"no_table"というテーブルから生成されたフォームのように生成されたhtmlの"id"属性を用いてフォームを生成します。このダミーテーブルの名前を変更したいときは、factoryの``table_name``属性を用いてください：
You need to use an underscore instead of a space for field labels, or explicitly pass a dictionary of ``labels`` to ``form_factory``, as you would for a ``SQLFORM``. By default ``SQLFORM.factory`` generates the form using html "id" attributes generated as if the form was generated from a table called "no_table". To change this dummy table name, use the ``table_name`` attribute for the factory:
``
form = SQLFORM.factory(...,table_name='other_dummy_name')
``:code

factoryから生成された2つのフォームを同じテーブルに配置する必要があり、かつ、CSSの競合を避けたい場合、``table_name``の変更が必要になります。
Changing the ``table_name`` is necessary if you need to place two factory generated forms in the same table and want to avoid CSS conflicts.

#### 複数テーブルでひとつのフォーム

例えば、参照によってリンクされた'client'と'address'というふたつのテーブルが存在し、顧客とその住所レコードをひとつのフォームで挿入したいとします。これは以下のようにできます：
It often happens that you have two tables (for example 'client' and
'address' which are linked together by a reference and you want to
create a single form that allows to insert info about one client and
its default address. Here is how:

model:
``
db.define_table('client',
     Field('name'))
db.define_table('address',
    Field('client',db.client,writable=False,readable=False),
    Field('street'),Field('city'))
``:code

controller:
``
def register():
    form=SQLFORM.factory(db.client,db.address)
    if form.process().accepted:
        id = db.client.insert(**db.client._filter_fields(form.vars))
        form.vars.client=id
        id = db.address.insert(**db.address._filter_fields(form.vars))
        response.flash='Thanks for filling the form'
    return dict(form=form)
``:code

SQLFORM.factory（両方のテーブルで公開されたフィールドからひとつのフォームを作成しバリデータも継承している）に注意してください。ひとつのフォームの受理で、あるデータはひとつ目のテーブル、残りは別のテーブルからと、ふたつの挿入を実施しています。
Notice the SQLFORM.factory (it makes ONE form using public fields from
both tables and inherits their validators too).
On form accepts this does two inserts, some data in one table and some
data in the other.

-------
複数テーブル間で共通のフィールド名が存在しない場合のみ動作します。
This only works when the tables don't have field names in common.
-------

### CRUD
``CRUD``:inxx ``crud.create``:inxx ``crud.update``:inxx ``crud.select``:inxx ``crud.search``:inxx ``crud.tables``:inxx ``crud.delete``:inxx

web2pyに最近追加されたものの1つは、SQLFORMの上にあるCreate/Read/Update/Delete (CRUD) APIです。CRUDはSQLFORMを作成しますが、フォームの作成、フォームの処理、通知、リダイレクトを、すべて1つの関数において補完することによって、コーディングを単純化します。
One of the recent additions to web2py is the Create/Read/Update/Delete (CRUD) API on top of SQLFORM.
CRUD creates an SQLFORM, but it simplifies the coding because it incorporates the creation of the form, the processing of the form, the notification, and the redirection, all in one single function.

初めに注意する点は、CRUDが他のこれまで使用してきたweb2pyのAPIと異なり、APIがすでに公開されていないことです。これはインポートしなければなりません。また、特定のデータベースにリンクする必要があります。例:
The first thing to notice is that CRUD differs from the other web2py APIs we have used so far because it is not already exposed. It must be imported. It also must be linked to a specific database. For example:
``
from gluon.tools import Crud
crud = Crud(db)
``:code

上で定義した``crud``オブジェクトは次のようなAPIを提供します：
The ``crud`` object defined above provides the following API:

``crud.tables``:inxx ``crud.create``:inxx ``crud.read``:inxx ``crud.update``:inxx ``crud.delete``:inxx ``crud.select``:inxx .
- ``crud.tables()``は、データベースに定義されているテーブルのリストを返します。
- ``crud.tables()`` returns a list of tables defined in the database.
- ``crud.create(db.tablename)``は、テーブルのtablenameに対する作成フォームを返します。
- ``crud.create(db.tablename)`` returns a create form for table tablename.
- ``crud.read(db.tablename, id)``は、tablenameとレコードidに対する読み取り専用のフォームを返します。
- ``crud.read(db.tablename, id)`` returns a readonly form for tablename and record id.
- ``crud.update(db.tablename, id)``は、tablenameとレコードidに対する更新フォームを返します。
- ``crud.update(db.tablename, id)`` returns an update form for tablename and record id.
- ``crud.delete(db.tablename, id)``は、レコードを削除します。
- ``crud.delete(db.tablename, id)`` deletes the record.
- ``crud.select(db.tablename, query)``は、テーブルから選択されたレコードのリストを返します。
- ``crud.select(db.tablename, query)`` returns a list of records selected from the table.
- ``crud.search(db.tablename)``は、(form, records)のタプルを返します。formは検索フォームで、recordsはサブミットされた検索フォームに基づくレコードのリストです。
- ``crud.search(db.tablename)`` returns a tuple (form, records) where form is a search form and records is a list of records based on the submitted search form.
- ``crud()``は、``request.args()``に基づいて、上記のうちの1つを返します。
- ``crud()`` returns one of the above based on the ``request.args()``.

たとえば、次のアクションは：
For example, the following action:
``
def data(): return dict(form=crud())
``:code

次のようなURLを公開します：
would expose the following URLs:
``
http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]
``:code

しかし、次のアクションは：
However, the following action:

``
def create_tablename():
    return dict(form=crud.create(db.tablename))
``:code

以下の作成メソッドしか公開しません
would only expose the create method

``
http://.../[app]/[controller]/create_tablename
``:code

また、次のアクションは：
While the following action:

``
def update_tablename():
    return dict(form=crud.update(db.tablename, request.args(0)))
``:code

以下の更新メソッドしか公開しません
would only expose the update method

``
http://.../[app]/[controller]/update_tablename/[id]
``:code

他も同様です。
and so on.

CRUDの挙動は二通りの方法でカスタマイズできます。1つは、``crud``オブジェクトにいくつかの属性を設定することです。もう1つは、各メソッドに追加のパラメータを渡すことです。
The behavior of CRUD can be customized in two ways: by setting some attributes of the ``crud`` object or by passing extra parameters to each of its methods.

#### 設定

ここに、現在のCRUD属性と、そのデフォルトの値と、意味のリスト一式を示します：
Here is a complete list of current CRUD attributes, their default values, and meaning:

すべてのcrudのフォームに認証をかけます：
To enforce authentication on all crud forms:

``
crud.settings.auth = auth
``:code
利用方法は第9章で説明します。
The use is explained in chapter 9.

``crud``オブジェクトを返す``data``関数を定義しているコントローラを指定します
To specify the controller that defines the ``data`` function which returns the ``crud`` object

``
crud.settings.controller = 'default'
``:code

レコードの"create"が成功した後のリダイレクト先のURLを指定します：
To specify the URL to redirect to after a successful "create" record:

``
crud.settings.create_next = URL('index')
``:code

レコードの"update"が成功した後のリダイレクト先のURLを指定します：
To specify the URL to redirect to after a successful "update" record:

``
crud.settings.update_next = URL('index')
``:code

レコードの"delete"が成功した後のリダイレクト先のURLを指定します：
To specify the URL to redirect to after a successful "delete" record:

``
crud.settings.delete_next = URL('index')
``:code

アップロードされたファイルへリンクするために使用するURLを指定します：
To specify the URL to be used for linking uploaded files:

``
crud.settings.download_url = URL('download')
``:code

``crud.create``フォームに対する標準の検証処理の後に実行される追加の関数を指定します：
To specify extra functions to be executed after standard validation procedures for ``crud.create`` forms:

``
crud.settings.create_onvalidation = StorageList()
``:code

``StorageList``は``Storage``オブジェクトと同様で、両者"gluon/storage.py"ファイルに定義されていますが、そのデフォルトは``None``ではなく``[]``になります。これにより、次の構文が使用できます：
``StorageList`` is the same as a ``Storage`` object, they are both defined in the file "gluon/storage.py", but it defaults to ``[]`` as opposed to ``None``. It allows the following syntax:

``
crud.settings.create_onvalidation.mytablename.append(lambda form:....)
``:code

``crud.update``フォームに対する標準の検証処理の後に実行される追加の関数を指定します：
To specify extra functions to be executed after	standard validation procedures for ``crud.update`` forms:

``
crud.settings.update_onvalidation = StorageList()
``:code

``crud.create``フォームの完了後に実行される追加の関数を指定します：
To specify extra functions to be executed after completion of ``crud.create`` forms:

``
crud.settings.create_onaccept = StorageList()
``:code

``crud.update``フォームの完了後に実行される追加の関数を指定します：
To specify extra functions to be executed after completion of ``crud.update`` forms:

``
crud.settings.update_onaccept = StorageList()
``:code

レコードが削除される場合において、``crud.update``の完了後に実行される追加の関数を指定します：
To specify extra functions to be executed after completion of ``crud.update`` if record is deleted:

``
crud.settings.update_ondelete = StorageList()
``:code

``crud.delete``の完了後に実行される追加の関数を指定します：
To specify extra functions to be executed after completion of ``crud.delete``:

``
crud.settings.delete_onaccept = StorageList()
``:code

"update"フォームが"delete"ボタンを持つかどうかを決めます：
To determine whether the "update" forms should have a "delete" button:

``
crud.settings.update_deletable = True
``:code

"update"フォームが編集レコードの"id"を表示するかどうかを決めます：
To determine whether the "update" forms should show the id of the edited record:

``
crud.settings.showid = False
``:code

フォームが前回挿入された値を維持するか、サブミット成功後デフォルトにリセットするかどうかを決めます：
To determine whether forms should keep the previously inserted values or reset to default after successful submission:

``
crud.settings.keepvalues = False
``:code

crudは編集されているレコードがフォーム表示時からサブミットの間に第3者によって修正されていないかを検知します。これは以下と等しいです。
Crud always detects whether a record being edited has been modified by a third party in the time between the time when the form is displayed and the time when it is submitted. This behavior is equivalent to
``
form.process(detect_record_change=True)``

そしてこにょうに設定します：
and it is set in:

``
crud.settings.detect_record_change = True
``:code
変数の値を``False``にすることで無効にすることができます。
and it can be changed/disabled by setting the variable to ``False``.

フォームのスタイルは次のようにして変更することができます
You can change the form style by

``
crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'
``:code

全てのcrudフォームに区切り文字を設定できます。
You can set the separator in all crud forms:

``
crud.settings.label_separator = ':'
``:code

authで説明されるのと同じやり方で、フォームにキャプチャを加えることができます：
You can add captcha to forms, using the same convention explained for auth, with:

``
crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None
``:code


#### メッセージ

カスタマイズ可能なメッセージのリストを以下に示します：
Here is a list of customizable messages:
``
crud.messages.submit_button = 'Submit'
``:code

これは、create、updateフォーム両方に対して"submit"ボタンのテキストを設定します。
sets the text of the "submit" button for both create and update forms.
``
crud.messages.delete_label = 'Check to delete:'
``:code

これは、"update"フォームにおいて"delete"ボタンのラベルを設定します。
sets the label of the "delete" button in "update" forms.
``
crud.messages.record_created = 'Record Created'
``:code

これは、レコードの作成が成功した際のflashメッセージを設定します。
sets the flash message on successful record creation.
``
crud.messages.record_updated = 'Record Updated'
``:code

これは、レコードの更新が成功した際のflashメッセージを設定します。
sets the flash message on successful record update.
``
crud.messages.record_deleted = 'Record Deleted'
``:code

これは、レコードの削除が成功した際のflashメッセージを設定します。
sets the flash message on successful record deletion.
``
crud.messages.update_log = 'Record %(id)s updated'
``:code

これは、レコードの更新が成功したときのログメッセージを設定します。
sets the log message on successful record update.
``
crud.messages.create_log = 'Record %(id)s created'
``:code

これは、レコードの作成が成功したときのログメッセージを設定します。
sets the log message on successful record creation.
``
crud.messages.read_log = 'Record %(id)s read'
``:code

これは、レコードの読み取りアクセスが成功したときのログメッセージを設定します。
sets the log message on successful record read access.
``
crud.messages.delete_log = 'Record %(id)s deleted'
``:code

これは、レコードの削除が成功したときのログメッセージを設定します。
sets the log message on successful record deletion.

なお、``crud.messages``は``gluon.storage.Message``クラスに所属しています。これは、``gluon.storage.Storage``に似ていますが、``T``演算子の必要なしに、自動的にその値を翻訳します。
Notice that ``crud.messages`` belongs to the class ``gluon.storage.Message`` which is similar to ``gluon.storage.Storage`` but it automatically translates its values, without need for the ``T`` operator.

ログメッセージは、CRUDが第9章で説明するAuthに接続された場合のみ使用されます。イベントは、Authテーブルの"auth_events"にログとして記録されます。
Log messages are used if and only if CRUD is connected to Auth as discussed in Chapter 9. The events are logged in the Auth table "auth_events".

#### メソッド

CRUDのメソッドの挙動は、呼び出し毎の原則でカスタマイズすることができます。ここにその用法を示します：
The behavior of CRUD methods can also be customized on a per call basis. Here are their signatures:
``
crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero, showall, chkall)
``:code
- ``table``は、DALのテーブル、または、テーブル名です。メソッドはその上で動作します。
- ``table`` is a DAL table or a tablename the method should act on.
- ``record``と``record_id``は、レコードのidです。メソッドはその上で動作します。
- ``record`` and ``record_id`` are the id of the record the method should act on.
- ``next``は、成功後にリダイレクトする先のURLです。URLが部分文字列"[id]"を含む場合、これは、現在作成/更新されたレコードのidによって置換されます。
- ``next`` is the URL to redirect to after success. If the URL contains the substring "[id]" this will be replaced by the id of the record currently created/updated.
- ``onvalidation``は、SQLFORM(..., onvalidation)と同じ機能を持ちます。
- ``onvalidation`` has the same function as SQLFORM(..., onvalidation)
- ``onaccept``は、フォームのサブミットが受理された後に呼ばれ、そこで、リダイレクトする前に、動作する関数です。
- ``onaccept`` is a function to be called after the form submission is accepted and acted upon, but before redirection.
- ``log``はログのメッセージです。CRUDにおけるログのメッセージは、form.vars``の辞書変数を"%(id)s"のように参照します。
- ``log`` is the log message. Log messages in CRUD see variables in the ``form.vars`` dictionary such as "%(id)s".
- ``message``はフォームが受理されたときのflashメッセージです。
- ``message`` is the flash message upon form acceptance.
- ``ondelete``は、"update"フォームを介してレコードが削除されるときに、`onaccept``の場所で呼ばれます。
- ``ondelete`` is called in place of ``onaccept`` when a record is deleted via an "update" form.
- ``deletable``は、"update"フォームがdeleteオプションを持つかどうかを決めます。
- ``deletable`` determines whether the "update" form should have a delete option.
- ``query``は、レコードを選択するために使用するクエリです。
- ``query`` is the query to be used to select records.
- ``fields``は、レコードを選択するために使用するクエリです。
- ``fields`` is a list of fields to be selected.
- ``orderby``は、選択したレコードの順序を決めます(第6章を参照してください)。
- ``orderby`` determines the order in which records should be selected (see Chapter 6).
- ``limitby``は、表示される選択レコードの範囲を決めます(第6章を参照してください)。
- ``limitby`` determines the range of selected records that should be displayed (see Chapter 6).
- ``headers``は、テーブルのヘッダの名前からなる辞書です。
- ``headers`` is a dictionary with the table header names.
- ``queries``は、``['equals', 'not equal', 'contains']``のようなリストです。検索フォームにおける使用可能なメソッドを保持します。
- ``queries`` a list like ``['equals', 'not equal', 'contains']`` containing the allowed methods in the search form.
- ``query_labels``は、``query_labels=dict(equals='Equals')``のような辞書です。検索メソッドに対する名前を与えます。
- ``query_labels`` a dictionary like ``query_labels=dict(equals='Equals')`` giving names to search methods.
- ``fields``は、検索ウィジェットにおいて列挙されるフィールドのリストです。
- ``fields`` a list of fields to be listed in the search widget.
- ``field_labels``は、フィールド名をラベルにマッピングする辞書です。
- ``field_labels`` a dictionary mapping field names into labels.
- ``zero``は、デフォルトでは"choose one"で、検索ウィジェットのドロップダウンのためのデフォルトのオプションとして使用されます。
- ``zero`` defaults to "choose one" is used as default option for the drop-down in the search widget.
- ``showall``は最初の呼び出し時にqueryで選択されたrowsを返したい場合はTrueを設定しておきます。（1.98.2以降に追加）
- ``showall`` set it to True if you want rows returned as per the query in the first call (added after 1.98.2).
- ``chkall``は検索フォームのチェックボックスを全てチェックしたい時にTrueを設定しておきます。（1.98.2以降に追加）
- ``chkall`` set it to True to turn on all the checkboxes in the search form (added after 1.98.2).

ここでは、単一のコントローラ関数における使用例を示します：
Here is an example of usage in a single controller function:
``
## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
           message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
           headers={'person.name': 'Name'})
    return dict(form=form, persons=persons)
``:code

もう1つのとても汎用的なコントローラ関数を示します。これにより、任意のテーブルから任意のレコードを検索、作成、編集することができます。このとき、テーブル名はrequest.args(0)によって渡されます：
Here is another very generic controller function that lets you search, create and edit any records from any table where the tablename is passed request.args(0):
``
def manage():
    table=db[request.args(0)]
    form = crud.update(table,request.args(1))
    table.id.represent = lambda id, row: \
       A('edit:',id,_href=URL(args=(request.args(0),id)))
    search, rows = crud.search(table)
    return dict(form=form,search=search,rows=rows)
``:code

なお、``table.id.represent=...``の行は、web2pyに対して、idフィールドの表現を変更し、代わりに、自分自身のページへのリンクを表示し、作成ページを更新ページに切り替えるためにidをrequest.args(1)として渡すように指示します。
Notice the line ``table.id.represent=...`` that tells web2py to change the representation of the id field and display a link instead to the page itself and passes the id as request.args(1) which turns the create page into an update page.

#### レコードのバージョニング

SQLFORMとCRUDは共にデータベースレコードのバージョニングを行うユーティリティを提供しています：
Both SQLFORM and CRUD provides a utility to version database records:

すべての改訂履歴を必要とするテーブル(db.mytable)を持ちたいなら、次のようにするだけです：
If you have a table (db.mytable) that needs full revision history you can just do:
``
form = SQLFORM(db.mytable, myrecord).process(onsuccess=auth.archive)
``:code

``
form = crud.update(db.mytable, myrecord, onaccept=auth.archive)
``:code

``auth.archive``は**db.mytable_archive**という新規のテーブルを定義します(この名前は参照するテーブルの名前に由来します)。そして、更新時に、(更新前の)レコードのコピーを、作成した記録用のテーブルに保存します。そのレコードへの参照も含まれます。
``auth.archive`` defines a new table called **db.mytable_archive** (the name is derived from the name of the table to which it refers) and on updating, it stores a copy of the record (as it was before the update) in the created archive table, including a reference to the current record.

レコードは実際に更新されるので(その前回の状態のみが記録されます)、参照が壊れることはありません。
Because the record is actually updated (only its previous state is archived), references are never broken.

これはすべて内部で行われます。記録テーブルにアクセスしたいならば、モデルにおいてそれを定義しておく必要があります：
This is all done under the hood.  Should you wish to access the archive table you should define it in a model:
``
db.define_table('mytable_archive',
   Field('current_record',db.mytable),
   db.mytable)
``:code

なお、テーブルは``db.mytable``を拡張し(そのすべてのフィールドを含み)、``current_record``へ参照を追加しています。
Notice the table extends ``db.mytable`` (including all its fields), and adds  a reference to the ``current_record``.

``auth.archive``は、次のように元のテーブルがtimestampフィールドを持たない限り、保存したレコードのタイムスタンプを取りません。
``auth.archive`` does not timestamp the stored record unless your original table has timestamp fields, for example:

``
db.define_table('mytable',
    Field('created_on','datetime',
          default=request.now,update=request.now,writable=False),
    Field('created_by',auth.user,
          default=auth.user_id,update=auth.user_id,writable=False),
``:code

これらのフィールドに関して何ら特別なことはなく、好きな名前を付けることが可能です。これらはレコードが記録される前に入力され、各レコードのコピーと共に記録されます。記録テーブルの名前、または/かつ、フィールドの名前は次のように変更することができます：
There is nothing special about these fields and you may give them any name you like. They are filled before the record is archived and are archived with each copy of the record.  The archive table name and/or reference field name can be changed like this:

``
db.define_table('myhistory',
    Field('parent_record',db.mytable),
    db.mytable)
## ...
form = SQLFORM(db.mytable,myrecord)
form.process(onsuccess = lambda form:auth.archive(form,
             archive_table=db.myhistory,
             current_record='parent_record'))
``:code

### カスタムフォーム

フォームがSQLFORMやSQLFORM.factory、CRUDを利用して作られている場合、それをビューに埋め込む方法は複数あり、複数の度合いのカスタマイズができるようになります。たとえば次のモデルを考えてみます：
If a form is created with SQLFORM, SQLFORM.factory or CRUD, there are multiple ways it can be embedded in a view allowing multiple degrees of customization. Consider for example the following model:
``
db.define_table('image',
    Field('name'),
    Field('file', 'upload'))
``:code

また、次のアップロード・アクションも考えます：
and upload action
``
def upload_image():
    return dict(form=crud.create(db.image))
``:code

最も簡単に、``upload_image``に対するビューにおいてフォームを埋め込む方法は次の通りです：
The simplest way to embed the form in the view for ``upload_image`` is
``
{{=form}}
``:code

これは標準のテーブル・レイアウトになります。別のレイアウトを使用したい場合、フォームを要素に分解することができます
This results in a standard table layout. If you wish to use a different layout, you can break the form into components
``
{{=form.custom.begin}}
Image name: <div>{{=form.custom.widget.name}}</div>
Image file: <div>{{=form.custom.widget.file}}</div>
Click here to upload: {{=form.custom.submit}}
{{=form.custom.end}}
``:code

ここで、``form.custom.widget[fieldname]``は、そのフィールドに対して適切なウィジェットにシリアライズされます。フォームがサブミットされてエラーを含む場合、そのエラーは従来通りウィジェットの下に追加されます。
where ``form.custom.widget[fieldname]`` gets serialized into the proper widget for the field. If the form is submitted and it contains errors, they are appended below the widgets, as usual.

上記のサンプルフォームは下図のように表示されます。
The above sample form is show in the image below.

[[image @:image/en6500.png center 300px]]

ただし、同様の結果は次のようにしても得られます：
Notice that a similar result could have been obtained with:

``
crud.settings.formstyle='table2cols'
``:code

この場合、カスタムフォームを使用していません。他の可能な``formstyle``は、"table3cols" (デフォルト)、"divs"、"ul"です。
without using a custom form. Other possible ``formstyle``s are "table3cols" (the default), "divs" and "ul".

web2pyによってシリアライズされたウィジェットを使用したくない場合は、それをHTMLで置き換えることができます。このために有用ないくつかの変数があります：
If you do not wish to use the widgets serialized by web2py, you can replace them with HTML. There are some variables that will be useful for this:
- ``form.custom.label[fieldname]``はフィールドのラベルを含みます。
- ``form.custom.label[fieldname]`` contains the label for the field.
- ``form.custom.comment[fieldname]``はフィールドのコメントを含みます。
- ``form.custom.comment[fieldname]`` contains the comment for the field.
- ``form.custom.dspval[fieldname]``はフィールドの表示方法に関わるform-typeとfield-typeを含みます。
- ``form.custom.dspval[fieldname]`` form-type and field-type dependent display representation of the field.
- ``form.custom.inpval[fieldname]``はフィールドの値に関するform-typeとfield-typeを含みます。
- ``form.custom.inpval[fieldname]`` form-type and field-type dependent values to be used in field code.

以下に説明する慣例に従うことは重要です。
It is important to follow the conventions described below.

#### CSSの慣例

SQLFORM、SQLFORM.factory、CRUDによって生成されたフォーム内の​​タグは、フォームのさらなるカスタマイズに使用することができる厳密なCSSの命名規則に従っています。
Tags in forms generated by SQLFORM, SQLFORM.factory and CRUD follow a strict CSS naming convention that can be used to further customize the forms.

"mytable"テーブルと"string"型の"myfield"フィールドが与えられたとき、次のものによってレンダリングされます。
Given a table "mytable", and a field "myfield" of type "string", it is rendered by default by a
``
SQLFORM.widgets.string.widget
``:code

これは次のようになります：
that looks like this:
``
<input type="text" name="myfield" id="mytable_myfield"
       class="string" />
``:code

以下のことに注意してください：
Notice that:
- INPUTタグのクラスはフィールドの型と同じです。これは"web2py_ajax.html"におけるjQueryのコードが機能するのに非常に重要です。これは、"integer"か"double"のフィールドにおいて数値しか持たないようにし、"time"、"date"、"datetime"のフィールドではポップアップのカレンダーが表示されるようにします。
- the class of the INPUT tag is the same as the type of the field. This is very important for the jQuery code in "web2py_ajax.html" to work. It makes sure that you can only have numbers in "integer" and "double" fields, and that "time", "date" and "datetime" fields display the popup calendar/datepicker.
- idは、クラスの名前とフィールドの名前をアンダースコアで結合したものです。これにより、たとえば``jQuery('#mytable_myfield')``のようにして一意に参照することができ、フィールドのスタイルシートを操作したり、フィールドのイベントに関連付けられたアクション(focus、blur、keyupなど)をバインドすることができるようになります。
- the id is the name of the class plus the name of the field, joined by one underscore. This allows you to uniquely refer to the field via, for example, ``jQuery('#mytable_myfield')`` and manipulate the stylesheet of the field or bind actions associated to the field events (focus, blur, keyup, etc.).
- nameは、想像通り、フィールド名になります。
- the name is, as you would expect, the field name.

#### エラーの非表示
``hideerror``:inxx

場合によっては、自動的なエラー配置を無効にして、フォームのエラーメッセージをデフォルトではないどこか別の場所に表示したいことがあります。これを行うのは簡単です。
Occasionally, you may want to disable the automatic error placement and display form error messages in some place other than the default. That can be done easily.

- FORMまたはSQLFORMの場合は、``hideerror=True``を``accepts``メソッドに渡してください。
- In the case of FORM or SQLFORM, pass ``hideerror=True`` to the ``accepts`` method.
- CRUDの場合は、``crud.settings.hideerror=True``に設定してください。
- In the case of CRUD, set ``crud.settings.hideerror=True``

エラーを表示するビューを変更したくなることもあります(もはや自動的に表示されないので)。
You may also want to modify the views to display the error (since they are no longer displayed automatically).

次の例では、エラーをフォームの中ではなく、フォームの上に表示されるようにしています。
Here is an example where the errors are displayed above the form and not in the form.
``
{{if form.errors:}}
  Your submitted form contains the following errors:
  <ul>
  {{for fieldname in form.errors:}}
    <li>{{=fieldname}} error: {{=form.errors[fieldname]}}</li>
  {{pass}}
  </ul>
  {{form.errors.clear()}}
{{pass}}
{{=form}}
``:code

エラーは下図のように表示されます：
The errors will displayed as in the image shown below.

[[image @:image/en6600.png center 300px]]

このメカニズムはカスタムフォームでも動作します。
This mechanism also works for custom forms.


### バリデータ
``validators``:inxx

バリデータは入力フィールド(データベース・テーブルから生成されたフォームを含む)を検証するために使用されるクラスです。
Validators are classes used to validate input fields (including forms generated from database tables).

``FORM``とともにバリデータを使用する例です：
Here is an example of using a validator with a ``FORM``:
``
INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))
``:code

どのようにテーブルのフィールドに対するバリデータを要求するかの例です：
Here is an example of how to require a validator for a table field:
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()
``:code

バリデータは常にフィールドの``requires``属性を用いて割り当てられます。フィールドは、単一もしくは複数のバリデータを持つことができます。複数のバリデータはリストの一部になります：
Validators are always assigned using the ``requires`` attribute of a field. A field can have a single validator or multiple validators. Multiple validators are made part of a list:
``
db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]
``:code

バリデータは``FORM``上の``accepts``と``process``関数や、フォームを含む他のHTMLヘルパーオブジェクトによって呼ばれます。それらは、列挙されている順序で呼ばれます。
Normally validators are called automatically by the function ``accepts`` and ``process`` of a ``FORM`` or other HTML helper object that contains a form. They are called in the order in which they are listed.

あるフィールドに対して明示的にバリデータを呼ぶこともできます。
One can also call validators explicitly for a field:

``
db.person.name.validate(value)
``

これは``(value,error)``のタプルを返し、検証する値が無い場合は``error``が``None``を返します。
which returns a tuple ``(value,error)`` and ``error`` is ``None`` if no the value validates.

組み込みのバリデータはオプション引数を取るコンストラクタを持っています：
Built-in validators have constructors that take an optional argument:

``
IS_NOT_EMPTY(error_message='cannot be empty')
``:code

``error_message``は、任意のバリデータに対してデフォルトのエラーメッセージをオーバーライドするようにします。
``error_message`` allows you to override the default error message for any validator.

データベース・テーブルに対するバリデータの例です：
Here is an example of a validator on a database table:
``
db.person.name.requires = IS_NOT_EMPTY(error_message=T'fill this!')
``:code

ここで、国際化対応のため``T``という翻訳演算子を使用しています。なお、デフォルトのエラーメッセージは翻訳されません。
where we have used the translation operator ``T`` to allow for internationalization. Notice that default error messages are not translated.

``list:``型のフィールドに対して使用されるバリデータは以下のみとなります。
Mind that the only validators that can be used with ``list:`` type fields are:

- ``IS_IN_DB(...,multiple=True)``
- ``IS_IN_SET(...,multiple=True)``
- ``IS_NOT_EMPTY()``
- ``IS_LIST_OF(...)``

一番最後のバリデータはリスト中の個別要素に対してバリデータを適用します。
The latter can be used to apply any validator to the individual items in the list.

#### バリデータ

##### ``IS_ALPHANUMERIC``
``IS_ALPHANUMERIC``:inxx

このバリデータは、フィールドの値がa～z、A～Z、0～9の範囲にある文字しか含まれていないことをチェックします。
This validator checks that a field value contains only characters in the ranges a-z, A-Z, or 0-9.
``
requires = IS_ALPHANUMERIC(error_message='must be alphanumeric!')
``:code

##### ``IS_DATE``
``IS_DATE``:inxx

このバリデータは、指定したフォーマットで有効な日付がフィールドの値に入っていることをチェックします。異なる場所の異なるフォーマットをサポートするために、翻訳演算子を用いてフォーマットを指定するのは良いプラクティスです。
This validator checks that a field value contains a valid date in the specified format. It is good practice to specify the format using the translation operator, in order to support different formats in different locales.
``
requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message='must be YYYY-MM-DD!')
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。
For the full description on % directives look under the IS_DATETIME validator.

##### ``IS_DATE_IN_RANGE``
``IS_DATE_IN_RANGE``:inxx

前のバリデータと非常に似ていますが、範囲を指定することができます：
Works very much like the previous validator but allows to specify a range:
``
requires = IS_DATE_IN_RANGE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008,1,1),
                   maximum=datetime.date(2009,12,31),
                   error_message='must be YYYY-MM-DD!')
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。
For the full description on % directives look under the IS_DATETIME validator.

##### ``IS_DATETIME``
``IS_DATETIME``:inxx

このバリデータは、指定したフォーマットで有効な日時がフィールドの値に入っていることをチェックします。異なる場所の異なるフォーマットをサポートするために、翻訳演算子を用いてフォーマットを指定するのは良いプラクティスです。
This validator checks that a field value contains a valid datetime in the specified format. It is good practice to specify the format using the translation operator, in order to support different formats in different locales.
``
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message='must be YYYY-MM-DD HH:MM:SS!')
``:code

以下のシンボルをフォーマット文字列に対して使用することができます(シンボルと例となる文字列を示します)：
The following symbols can be used for the format string (this shows the symbol and an example string):
``
%Y  '1963'
%y  '63'
%d  '28'
%m  '08'
%b  'Aug'
%b  'August'
%H  '14'
%I  '02'
%p  'PM'
%M  '30'
%S  '59'
``:code

##### ``IS_DATETIME_IN_RANGE``
``IS_DATETIME_IN_RANGE``:inxx

前のバリデータと非常に似ていますが、範囲を指定することができます：
Works very much like the previous validator but allows to specify a range:
``
requires = IS_DATETIME_IN_RANGE(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008,1,1,10,30),
                       maximum=datetime.datetime(2009,12,31,11,45),
                       error_message='must be YYYY-MM-DD HH:MM::SS!')
``:code

%ディレクティブの詳細な説明はIS_DATETIMEバリデータの項目を参照してください。
For the full description on % directives look under the IS_DATETIME validator.

##### ``IS_DECIMAL_IN_RANGE``
``IS_DECIMAL_IN_RANGE``:inxx

``
INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10, dot="."))
``:code

入力をPythonのDecimalへと変換します。もしくは、数値が指定した範囲に収まっていない場合はエラーを生成します。比較はPythonのDecimalの算術で行われます。
It converts the input into a Python Decimal or generates an error if
the decimal does not fall within the specified inclusive range.
The comparison is made with Python Decimal arithmetic.

最小値と最大値にはNoneを設定することができ、それぞれ。下限なし、上限なしを意味します。
The minimum and maximum limits can be None, meaning no lower or upper limit,
respectively.

``dot``引数はオプションで小数を区切る記号を国際化できます。
The ``dot`` argument is optional and allows you to internationalize the symbol used to separate the decimals.


##### ``IS_EMAIL``
``IS_EMAIL``:inxx

フィールドの値がemailのアドレスのようになっているかをチェックします。確認のためemailを送信することは試みません。
It checks that the field value looks like an email address. It does not try to send email to confirm.
``
requires = IS_EMAIL(error_message='invalid email!')
``:code

##### ``IS_EQUAL_TO``
``IS_EQUEL_TO``:inxx

検証された値が与えられた値(変数にすることもできます)と等しいかチェックします：
Checks whether the validated value is equal to a given value (which can be a variable):
``
requires = IS_EQUAL_TO(request.vars.password,
                       error_message='passwords do not match')
``:code

##### ``IS_EXPR``
``IS_EXPR``:inxx

最初の引数は、変数に値に関する論理的な表現を保持する文字列です。フィールドの値を、その式がTrueに評価されるかどうかで検証します。例:
Its first argument is a string containing a logical expression in terms of a variable value. It validates a field value if the expression evaluates to ``True``. For example:
``
requires = IS_EXPR('int(value)%3==0',
                   error_message='not divisible by 3')
``:code

例外が発生しないように、初めに整数であることをチェックしたほうがよいでしょう。
One should first check that the value is an integer so that an exception will not occur.
``
requires = [IS_INT_IN_RANGE(0, 100), IS_EXPR('value%3==0')]
``:code

##### ``IS_FLOAT_IN_RANGE``
``IS_FLOAT_IN_RANGE``:inxx

フィールドの値が範囲内の浮動小数点になっていることをチェックします。次の例では、``0 <= value <= 100``の範囲をチェックしています：
Checks that the field value is a floating point number within a definite range, ``0 <= value <= 100`` in the following example:
``
requires = IS_FLOAT_IN_RANGE(0, 100, dot=".",
         error_message='too small or too large!')
``:code

``dot``引数はオプションで小数を区切る記号を国際化できます。
The ``dot`` argument is optional and allows you to internationalize the symbol used to separate the decimals.

##### ``IS_INT_IN_RANGE``
``IS_INT_IN_RANGE``:inxx

フィールドの値が範囲内の整数になっていることをチェックします。次の例では、``0 <= value <= 100``の範囲をチェックしています：
Checks that the field value is an integer number within a definite range,
 ``0 <= value < 100`` in the following example:

``
requires = IS_INT_IN_RANGE(0, 100,
         error_message='too small or too large!')
``:code

##### ``IS_IN_SET``
``IS_IN_SET``:inxx
``multiple``:inxx

フィールドの値がセットに含まれていることをチェックします：
Checks that the field values are in a set:
``
requires = IS_IN_SET(['a', 'b', 'c'],zero=T('choose one'),
         error_message='must be a or b or c')
``:code

zero引数は省略可能で、デフォルトで選択されたオプション、つまり、``IS_IN_SET``バリデータ自身によって受理されないオプション、のテキストを決めます。"chooose one"オプションを望まない場合は、``zero=None``としてください。
The zero argument is optional and it determines the text of the option selected by default, an option which is not accepted by the ``IS_IN_SET`` validator itself. If you do not want a "choose one" option, set ``zero=None``.

``zero``オプションはリビジョン(1.67.1)において導入されました。これは、アプリケーションを壊さないという意味で後方互換性を破りませんでした。しかし、以前は``zero``オプションがなかったので、その挙動は変化しました。
The ``zero`` option was introduced in revision (1.67.1). It did not break backward compatibility in the sense that it did not break applications but it did change their behavior since, before, there was no ``zero`` option.

セットの要素は常に文字列でなければなりません。ただし、このバリデータが``IS_INT_IN_RANGE``(値をintに変換)か``IS_FLOAT_RANGE``(値をfloatに変換)の後に続く場合はその限りではありません。例:
The elements of the set must always be strings unless this validator is preceded by ``IS_INT_IN_RANGE`` (which converts the value to int) or  ``IS_FLOAT_IN_RANGE`` (which converts the value to float). For example:
``
requires = [IS_INT_IN_RANGE(0, 8), IS_IN_SET([2, 3, 5, 7],
          error_message='must be prime and less than 10')]
``:code

辞書型やタプルのリストを使ってより記述的なドロップダウンリストを作成することもできます。
You may also use a dictionary or a list of tuples to make the drop down list more descriptive:
``
#### Dictionary example:
requires = IS_IN_SET({'A':'Apple','B':'Banana','C':'Cherry'},zero=None)
#### List of tuples example:
requires = IS_IN_SET([('A','Apple'),('B','Banana'),('C','Cherry')])
``:code


##### ``IS_IN_SET``とタグ付け

``IS_IN_SET``バリデータは``multiple=False``というオプション属性を持ちます。これがTrueに設定されている場合、複数の値を1つのフィールドに格納することができます。フィールドの型は、``list:integer``か``list:string``にしてください。``multiple``参照は、作成と更新フォームにおいて自動的に処理されます。しかし、DALに対して透過的ではありません。multipleフィールドをレンダリングするためには、jQueryのmultiselectプラグインを使用することを強く勧めます。
The ``IS_IN_SET`` validator has an optional attribute ``multiple=False``. If set to True, multiple values can be stored in one field. The field should be of type ``list:integer`` or ``list:string``. ``multiple`` references are handled automatically in create and update forms, but they are transparent to the DAL. We strongly suggest using the jQuery multiselect plugin to render multiple fields.

------
``multiple=True``の場合、``IS_IN_SET``は``zero``や他の値を許可します。つまり、何も選択していないフィールドを許可するということになります。``multiple``はそれぞれ選択できる最小と最大（排他的）である``a``と``b``を持つ、フォーム``(a,b)``のタプルを使用することもできます。
Note that when ``multiple=True``, ``IS_IN_SET`` will accept ``zero`` or more values, i.e. it will accept the field when nothing has been selected. ``multiple`` can also be a tuple of the form ``(a,b)`` where ``a`` and ``b`` are the minimum and (exclusive) maximum number of items that can be selected respectively.
------

##### ``IS_LENGTH``
``IS_LENGTH``:inxx

フィールドの値の長さが与えられた境界の間に収まることをチェックします。テキストとファイルの入力の両方で機能します。
Checks if length of field's value fits between given boundaries. Works
for both text and file inputs.

引数は次の通りです：
Its arguments are:
- maxsize: 最大許容の長さ/サイズ(デフォルトは255)
- maxsize: the maximum allowed length / size (has default = 255)
- minsize: 最小許容の長さ/サイズ
- minsize: the minimum allowed length / size

例：テキストの文字列が33文字よりも短いかをチェックします：
Examples:
Check if text string is shorter than 33 characters:
``
INPUT(_type='text', _name='name', requires=IS_LENGTH(32))
``:code

例：テキストの文字列が5文字よりも長いかをチェックします：
Check if password string is longer than 5 characters:
``
INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))
``:code

アップロードされたファイルのサイズが1KBと1MBの間にあるかをチェックします：
Check if uploaded file has size between 1KB and 1MB:
``
INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))
``:code

ファイルを除くすべてのフィールドの型に対して、値の長さをチェックします。ファイルの場合は、値は``cookie.FieldStorage``になります。したがって、直感的に予想できる挙動であるファイルのデータ長をチェックすることになります。
For all field types except for files, it checks the length of the value. In the case of files, the value is a ``cookie.FieldStorage``, so it validates the length of the data in the file, which is the behavior one might intuitively expect.

##### ``IS_LIST_OF``
``IS_LIST_OF``:inxx

これは正確にはバリデータではありません。その使用目的は、複数の値を返すフィールドの検証を可能にすることです。フォームが同じ名前の複数のフィールドや複数選択ボックスを含む場合といった稀なケースにおいて使用されます。唯一の引数は、別のバリデータです。別のバリデータをリストの各要素に適用することしかしません。たとえば、次の式はリストの各項目が0～10の範囲にある整数であることをチェックします：
This is not properly a validator. Its intended use is to allow validations of fields that return multiple values. It is used in those rare cases when a form contains multiple fields with the same name or a multiple selection box. Its only argument is another validator, and all it does is to apply the other validator to each element of the list. For example, the following expression checks that every item in a list is an integer in the range 0-10:
``
requires = IS_LIST_OF(IS_INT_IN_RANGE(0, 10))
``:code

これは、エラーを返すことはなく、エラーメッセージも含まれません。内部のバリデータがエラーの発生を制御します。
It never returns an error and does not contain an error message. The inner validator controls the error generation.

##### ``IS_LOWER``
``IS_LOWER``:inxx

このバリデータは決してエラーを返しません。単に、値を小文字に変換します。
This validator never returns an error. It just converts the value to lower case.
``
requires = IS_LOWER()
``:code

##### ``IS_MATCH``
``IS_MATCH``:inxx

このバリデータは、値を正規表現と照合し、一致してない場合はエラーを返します。米国の郵便番号を検証する使用例を示します：
This validator matches the value against a regular expression and returns an error if it does not match.
Here is an example of usage to validate a US zip code:
``
requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')
``:code

IPv4アドレスを検証する使用例です(ただし、IS_IPV4バリデータのほうがこの目的のためにはより妥当です)：
Here is an example of usage to validate an IPv4 address (note: the IS_IPV4 validator is more appropriate for this purpose):
``
requires = IS_MATCH('^\d{1,3}(\.\d{1,3}){3}$',
         error_message='not an IP address')
``:code

米国の電話番号を検証するための使用例です：
Here is an example of usage to validate a US phone number:
``
requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')
``:code

Pythonの正規表現の詳細については、公式のPythonのマニュアルを参照してください。
For more information on Python regular expressions, refer to the official Python documentation.

``IS_MATCH``はデフォルトで``False``に設定されている``strict``というオプションの引数を受け取ります。``True``が設定されている場合は、最初の文字だけを照合します。
``IS_MATCH`` takes an optional argument ``strict`` which defaults to ``False``. When set to ``True`` it only matches the beginning of the string:

``
>>> IS_MATCH('a')('ba')
('ba', <lazyT 'invalid expression'>) # no pass
>>> IS_MATCH('a',strict=False)('ab')
('a', None)                          # pass!
``

``IS_MATCH``はデフォルトで``False``に設定されている``search``というオプションの引数を受け取ります。``True``が設定されている場合は、``match``の代わりに正規表現の``search``を利用して文字を検証します。
``IS_MATCH`` takes an other optional argument ``search`` which defaults to ``False``. When set to ``True``, it uses regex method ``search`` instead of method ``match`` to validate the string.

##### ``IS_NOT_EMPTY``
``IS_NOT_EMPTY``:inxx

このバリデータは、フィールドの値が空の文字列ではないことをチェックします。
This validator checks that the content of the field value is not an empty string.
``
requires = IS_NOT_EMPTY(error_message='cannot be empty!')
``:code

##### ``IS_TIME``
``IS_TIME``:inxx

このバリデータは、指定したフォーマットでの有効な時間がフィールドの値に入力されていることをチェックします。
This validator checks that a field value contains a valid time in the specified format.
``
requires = IS_TIME(error_message='must be HH:MM:SS!')
``:code

##### ``IS_URL``
``IS_URL``:inxx

次のいずれかに該当するURL文字列を拒否します：
Rejects a URL string if any of the following is true:
- 文字列が空またはNone
- The string is empty or None
- 文字列がURLで許可されていない文字を使用する
- The string uses characters that are not allowed in a URL
- 文字列がHTTP構文規則のいずれかを破る
- The string breaks any of the HTTP syntactic rules
- (指定した場合)URLのスキームが'http'か'https'でない
- The URL scheme specified (if one is specified) is not 'http' or 'https'
- (ホスト名を指定した場合)トップレベルのドメインが存在しない
- The top-level domain (if a host name is specified) does not exist

(これらの規則は、RFC 2616``RFC2616``:citeに基づいています)
(These rules are based on RFC 2616``RFC2616``:cite )

この関数はURLの構文をチェックすることしかしません。たとえば、URLが実際の文章を指しているか、語義的に理にかなっているかはチェックしません。この関数は、省略URL('google.ca'など)の場合、自動的にURLの前に'http://'を追加します。
This function only checks the URL's syntax. It does not check that the URL points to a real document,
for example, or that it otherwise makes semantic sense. This function does automatically prepend
'http://' in front of a URL in the case of an abbreviated URL (e.g. 'google.ca').

mode='generic'というパラメータが使用されている場合、この関数の挙動は変化します。このときは、次のいずれかに該当するURL文字列を拒否します：
If the parameter mode='generic' is used, then this function's behavior changes. It then rejects a URL string if any of the following is true:
- 文字列が空またはNone
- The string is empty or None
- 文字列がURLで許可されていない文字を使用する
- The string uses characters that are not allowed in a URL
- (指定した場合)URLのスキームが有効でない
- The URL scheme specified (if one is specified) is not valid

(これらの規則は、RFC 2396``RFC2396``:citeに基づいています)
(These rules are based on RFC 2396``RFC2396``:cite )

許可されたスキーマのリストはallowed_schemesパラメータを使用してカスタマイズすることができます。リストからNoneを取り除いた場合、('http'のようなスキームを欠く)省略URLは拒否されます。
The list of allowed schemes is customizable with the allowed_schemes parameter. If you exclude None from
the list, then abbreviated URLs (lacking a scheme such as 'http') will be rejected.

デフォルトで先頭に追加されるスキーマはprepend_schemeパラメータでカスタマイズすることができます。prepend_schemeをNoneに設定した場合、先頭への追加は無効になります。それでも、解析のために先頭への追加が必要なURLは受け入れられますが、戻り値は変更されません。
The default prepended scheme is customizable with the prepend_scheme parameter. If you set prepend_scheme
to None, then prepending will be disabled. URLs that require prepending to parse will still be accepted,
but the return value will not be modified.

IS_URLは、RFC3490``RFC3490``:citeで指定されている国際化ドメイン名(IDN)の標準と互換性があります。その結果、URLには、通常の文字列またはUnicode文字列を指定できます。URLのドメイン・コンポーネント(たとえば、google.ca)が非US-ASCII文字を含んでいる場合、ドメインは(RFC3492``RFC3492``:citeで定義された)Punycodeに変換されます。IS_URLは標準を少しだけ越えて、非US-ASCII文字がURLのパスとクエリのコンポーネントにも提示されることを許可しています。これらの非US-ASCII文字はエンコードされます。たとえば、スペースは、'％20'にエンコードされます。16進数のUnicode文字0x4e86は'%4e%86'になります。
IS_URL is compatible with the Internationalized Domain Name (IDN) standard specified in RFC 3490``RFC3490``:cite ). As a result, URLs can be regular strings or unicode strings.
If the URL's domain component (e.g. google.ca) contains non-US-ASCII letters, then the domain will
be converted into Punycode (defined in RFC 3492``RFC3492``:cite ). IS_URL goes a
bit beyond the standards, and allows non-US-ASCII characters to be present in the path
and query components of the URL as well. These non-US-ASCII characters will be encoded.
For example, space will be encoded as'%20'. The unicode character with hex code 0x4e86
will become '%4e%86'.

例：
Examples:
``
requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'],
                  prepend_scheme='https')
``:code

##### ``IS_SLUG``
``IS_SLUG``:inxx
``
requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')
``:code

``check``がTrueに設定されている場合、検証される値が(英数字と繰り返しなしのダッシュのみ許可する)スラグかどうかをチェックします。
If ``check`` is set to ``True`` it check whether the validated value is a slug (allowing only alphanumeric characters and non-repeated dashes).

``check``がFalseの場合(デフォルト)、入力値をスラグに変換します。
If ``check`` is set to ``False`` (default) it converts the input value to a slug.

##### ``IS_STRONG``
``IS_STRONG``:inxx

フィールド(通常はパスワードフィールド)の複雑さの要求を強制します。
Enforces complexity requirements on a field (usually a password field)

例：
Example:
``
requires = IS_STRONG(min=10, special=2, upper=2)
``:code

ここで、
where
- minは値の最小の長さです
- min is minimum length of the value
- specialは要求される特殊文字の最小数です。特殊文字は、次のいずれかなります``@#$%^&*(){}[]-+``
- special is the minimum number of required special characters special characters are any of the following ``!@#$%^&*(){}[]-+``
- upperは大文字の最小数です
- upper is the minimum number of upper case characters

##### ``IS_IMAGE``
``IS_IMAGE``:inxx

このバリデータは、ファイル入力からアップロードされたファイルが選択した画像のフォーマットの1つで保存されているか、また、与えられた制約内の寸法(幅と高さ)を持っているかどうかをチェックします。
This validator checks if a file uploaded through the file input was saved in one of the selected image formats and has dimensions (width and height) within given limits.

これは、最大ファイルサイズはチェックしていません(そのためにはIS_LENGTHを使用してください)。何もデータがアップロードされていない場合は、検証エラーを返します。BMP、GIF、JPEG、PNGのファイル形式をサポートしています。Python Imaging Libraryは必要ありません。
It does not check for maximum file size (use IS_LENGTH for that). It returns
a validation failure if no data was uploaded. It supports the file formats BMP, GIF, JPEG, PNG, and it does not require the Python Imaging Library.

コードの一部は参照``source1``:citeから取っています。
Code parts taken from ref.``source1``:cite

次の引数を取ります：
It takes the following arguments:
- extensions: 許可する小文字の画像ファイル拡張子を保持する反復可能オブジェクト
- extensions: iterable containing allowed image file extensions in lowercase
- maxsize: 画像の最大の幅と高さを保持する反復可能オブジェクト
- maxsize: iterable containing maximum width and height of the image
- minsize: 画像の最小の幅と高さを保持する反復可能オブジェクト
- minsize: iterable containing minimum width and height of the image

画像サイズのチェックを回避するには、minsizeとして(-1, -1)を使用してください。
Use (-1, -1) as minsize to bypass the image-size check.

いくつかの例を示します：
Here are some Examples:
- アップロードされたファイルがサポートされている画像フォーマットのいずれかに含まれるかをチェックします：
- Check if uploaded file is in any of supported image formats:
``
requires = IS_IMAGE()
``:code
- アップロードされたファイルがJPEGまたはPNG形式かをチェックします：
- Check if uploaded file is either JPEG or PNG:
``
requires = IS_IMAGE(extensions=('jpeg', 'png'))
``:code

- アップロードされたファイルが最大200x200ピクセルのサイズのPNGであるかをチェックします：
- Check if uploaded file is PNG with maximum size of 200x200 pixels:
``
requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))
``:code

- 注記: ``requires = IS_IMAGE()``を含むテーブルの編集フォームを表示している場合、ファイルが削除されると検証を通らないので``delete``チェックボックスが表示されません。``delete``チェックボックスを表示したい場合は次のバリデータを使用してください。
- Note: on displaying an edit form for a table including ``requires = IS_IMAGE()``, a ``delete`` checkbox will NOT appear because to delete the file would cause the validation to fail. To display the ``delete`` checkbox use this validation:
``
requires = IS_EMPTY_OR(IS_IMAGE())
``:code


##### ``IS_UPLOAD_FILENAME``
``IS_UPLOAD_FILENAME``:inxx

このバリデータは、ファイル入力からアップロードされたファイルの名前と拡張子が与えられた条件に一致するかをチェックします。
This validator checks if the name and extension of a file uploaded through the file input matches the given criteria.

どのような方法であれ、これはファイルの型を保証するものではありません。何もデータがアップロードされていない場合は、検証エラーを返します。
It does not ensure the file type in any way. Returns validation failure
if no data was uploaded.

引数は次の通りです：
Its arguments are:
- filename: (ドットの前の)ファイル名の正規表現です。
- filename: filename (before dot) regex.
- extension: (ドットの後の)拡張子の正規表現です。
- extension: extension (after dot) regex.
- lastdot: どのドットがファイル名/拡張子の区分に使用されるか：``True``の場合、最後のドットとなります(たとえば、"file.tar.gz"は"file.tar"+"gz"に分解されます)。一方``False``の場合、最初のドットになります(たとえば、"file.tar.gz"は"file"+"tar.gz"に分解されます)。
- lastdot: which dot should be used as a filename / extension separator: ``True`` indicates last dot (e.g., "file.tar.gz" will be broken in "file.tar" + "gz") while ``False`` means first dot (e.g., "file.tar.gz" will be broken into "file" + "tar.gz").
- case: 0は大文字小文字を維持します。1は文字列を小文字に変換します(デフォルト)。2は文字列を大文字に変換します。
- case: 0 means keep the case; 1 means transform the string into lowercase (default); 2 means transform the string into uppercase.

dotが存在しない場合、拡張子は空の文字列に対してチェックされ、ファイル名はすべての文字列に対してチェックされます。
If there is no dot present, extension checks will be done against an empty
string and filename checks will be done against the whole value.

例：
Examples:

ファイルがpdfの拡張子を持つかをチェックします(大文字小文字は区別しません)：
Check if file has a pdf extension (case insensitive):
``
requires = IS_UPLOAD_FILENAME(extension='pdf')
``:code

ファイルがtar.gz拡張子を持ち、かつ、backupで始まる名前を持つかをチェックします：
Check if file has a tar.gz extension and name starting with backup:
``
requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)
``:code

ファイルが、拡張子を持たず、かつ、名前がREADMEに一致するかをチェックします(大文字小文字を区別します)：
Check if file has no extension and name matching README (case sensitive):
``
requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)
``:code

##### ``IS_IPV4``
``IS_IPV4``:inxx

このバリデータは、フィールドの値が10進数形式のIPバージョン4のアドレスかをチェックします。特定の範囲のアドレスに強制するように設定できます。
This validator checks if a field's value is an IP version 4 address in decimal form. Can
be set to force addresses from a certain range.

IPv4の正規表現は参照``regexlib``:citeから取っています。
IPv4 regex taken from ref.``regexlib``:cite
引数は以下の通りです。
Its arguments are:
- ``minip``許容する最下限のアドレス。str(例：192.168.0.1)や、反復可能な数字(例：[192, 168, 0, 1])や、int(例：3232235521)を受け入れます。
- ``minip`` lowest allowed address; accepts: **str**, e.g., 192.168.0.1; **iterable of numbers**, e.g., [192, 168, 0, 1]; **int**, e.g., 3232235521
- ``maxip``許容する最上限のアドレス。上と同様に受け入れます。
- ``maxip`` highest allowed address; same as above

ここにある3つの例の値は同じです。アドレスは、次の関数で包含チェックをするために、整数に変換されるからです：
All three example values are equal, since addresses are converted to
integers for inclusion check with following function:
``
number = 16777216 * IP[0] + 65536 * IP[1] + 256 * IP[2] + IP[3]
``:code

例：
Examples:

有効なIPv4のアドレスに対するチェックをします：
Check for valid IPv4 address:
``
requires = IS_IPV4()
``:code

有効なプライベートネットワークのIPv4のアドレスに対するチェックをします：
Check for valid private network IPv4 address:
``
requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')
``:code

##### ``IS_LOWER``
``IS_LOWER``:inxx

このバリデータはエラーを返すことはありません。値を小文字に変換します。
This validator never returns an error. It converts the value to lower case.
``
requires = IS_LOWER()
``:code

##### ``IS_UPPER``
``IS_UPPER``:inxx

このバリデータはエラーを返すことはありません。値を大文字に変換します。
This validator never returns an error. It converts the value to upper case.
``
requires = IS_UPPER()
``:code

##### ``IS_NULL_OR``
``IS_NULL_OR``:inxx

現在のバージョンでは使用されておらず、下に記述する``IS_EMPTY_OR``の別名です。
Deprecated, an alias for ``IS_EMPTY_OR`` described below.

##### ``IS_EMPTY_OR``
``IS_EMPTY_OR``:inxx

他の要求を満たしつつフィールドに空の値を許可したい場合があります。たとえば、フィールドは日付だが、空の値にもなりうるという場合です。``IS_EMPTY_OR``バリデータはこれを可能にします：
Sometimes you need to allow empty values on a field along with other requirements. For example a field may be a date but it can also be empty.
The ``IS_EMPTY_OR`` validator allows this:
``
requires = IS_EMPTY_OR(IS_DATE())
``:code

##### ``CLEANUP``
``CLEANUP``:inxx

これはフィルタです。失敗することはありません。単に、[10、13、32〜127]のリストに含まれない10進数のASCIIコードを持つすべての文字を削除します。
This is a filter. It never fails. It just removes all characters whose decimal ASCII codes are not in the list [10, 13, 32-127].
``
requires = CLEANUP()
``:code

##### ``CRYPT``
``CRYPT``:inxx

これもフィルタです。入力に対して安全なハッシュを実行します。パスワードがデータベースにそのまま渡されるのを防ぐのに使用されます。
This is also a filter. It performs a secure hash on the input and it is used to prevent passwords from being passed in the clear to the database.
``
requires = CRYPT()
``:code

keyが指定されていない場合、MD5アルゴリズムが使用されます。keyが指定されている場合、CRYPTはHMACアルゴリズムを用います。keyには、HMACとともに使用するアルゴリズムを決める接頭辞を含めることも可能です。たとえば、SHA512は次のようになります：
If a key is not specified, it uses the MD5 algorithm. If a key is specified CRYPT uses the HMAC algorithm. The key may contain a prefix that determines the algorithm to use with HMAC, for example SHA512:

``
requires = CRYPT(key='sha512:thisisthekey')
``:code

これは、推奨される構文です。keyは、使用されるデータベースに関連付けられた一意の文字列でなければなりません。keyは変更することはできません。keyを失うと、それ以前にハッシュ化された値は使用できなくなります。
This is the recommended syntax. The key has to be a unique string associated to the database used. The key can never be changed. If you lose the key the previously hashed values become useless.

CRYPTバリデータは入力をハッシュ化するので、ある意味特別な処理と言えます。ハッシュ化される前にパスワードフィールドを検証したい場合は、CRYPTをバリデータのリストに入れることで可能ですが、最後に呼ばれるようにするために、リストの一番最後に追加する必要があります。例:
The CRYPT validator hashed the input and this makes it somewhat special. If you need to validate a password field, before it is hash, you can use CRYPT in a list of validators but must make sure it is the last of the list so that it is called last. For example:

``
requires = [IS_STRONG(),CRYPT(key='sha512:thisisthekey')]
``:code

``CRYPT``はデフォルト値がゼロである``min_length``引数を取ることもできます。
``CRYPT`` also takes a ``min_length`` argument which defaults to zero.

#### データベースのバリデータ

##### ``IS_NOT_IN_DB``
``IS_NOT_IN_DB``:inxx

次の例を考えます：
Consider the following example:
``
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

これは、新規のpersonを挿入したとき、彼/彼女の名前がデータベース``db``のフィールド``person.name``にすでに存在していないことを要求します。他のバリデータと同様、この要求はフォーム処理のレベルで強制され、データベースレベルではされません。これには次のわずかな可能性があります。2人の訪問者が同時に、同じperson.nameを持つレコードを挿入しようとした場合、競合状態を引き起こし、両者のレコードが受け入れられてしまうことです。したがって、データベースに対しても、このフィールドが一意の値を持つということを知らせるほうが安全です：
It requires that when you insert a new person, his/her name is not already in the database, ``db``, in the field ``person.name``. As with all other validators this requirement is enforced at the form processing level, not at the database level. This means that there is a small probability that, if two visitors try to concurrently insert records with the same person.name, this results in a race condition and both records are accepted. It is therefore safer to also inform the database that this field should have a unique value:
``
db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
``:code

このとき、競合状態が発生した場合、データベースはOperationalErrorを発生させ、2つのうちの1つの挿入が拒否されます。
Now if a race condition occurs, the database raises an OperationalError and one of the two inserts is rejected.

``IS_NOT_IN_DB``の最初の引数は、データベース接続かSetにすることができます。後者の場合、Setで定義されたセットのみをチェックするようになります。
The first argument of ``IS_NOT_IN_DB`` can be a database connection or a Set. In the latter case, you would be checking only the set defined by the Set.

例えば次のコードは、10日以内に同じ名前を持つ2人のpersonsの登録を許可しません：
The following code, for example, does not allow registration of two persons with the same name within 10 days of each other:
``
import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp>now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')
``:code

##### ``IS_IN_DB``
``IS_IN_DB``:inxx

次のテーブルと要求を考えてください：
Consider the following tables and requirement:

``
db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
``:code

これは、dogの挿入/更新/削除フォームのレベルで強制されます。これは、``dog.owner``が``db``データベースの``person.id``フィールドにおいて有効なidになっていることを要求します。このバリデータのおかげで、``dog.owner``フィールドはドロップボックスによって表現されます。バリデータの3番目の引数は、ドロップボックスの内の要素を説明する文字列です。この例では、personの``%(id)s``の代わりに、personの``%(name)s``を見たいことになります。%(...)sは、各レコードに対して括弧内においてフィールドの値によって置き換えられます。
It is enforced at the level of dog INSERT/UPDATE/DELETE forms. It requires that a ``dog.owner`` be a valid id in the field ``person.id`` in the database ``db``. Because of this validator, the ``dog.owner`` field is represented as a dropbox. The third argument of the validator is a string that describes the elements in the dropbox. In the example you want to see the person ``%(name)s`` instead of the person ``%(id)s``. ``%(...)s`` is replaced by the value of the field in brackets for each record.

``zero``オプションは``IS_IN_SET``バリデータに対するものと非常によく似た動作をします。
The ``zero`` option works very much like for the ``IS_IN_SET`` validator.

バリデータの最初の引数は``IS_NOT_IN_DB``のようにデータベース接続やDALセットも使用できます。これはドロップボックスのレコードを制限したい場合などに活用できます。次の例では、コントローラが呼ばれるたびに動的にレコードを制限するように``IS_IN_DB``を使用しています。
The first argument of the validator can be a database connection or a DAL Set, as in ``IS_NOT_IN_DB``. This can be useful for example when wishing to limit the records in the drop-down box. In this example, we use ``IS_IN_DB`` in a controller to limit the records dynamically each time the controller is called:

``
def index():
    (...)
    query = (db.table.field == 'xyz') #in practice 'xyz' would be a variable
    db.table.field.requires=IS_IN_DB(db(query),....)
    form=SQLFORM(...)
    if form.process().accepted: ...
    (...)
``:code

フィールドの検証はしたいが、ドロップボックスを表示したくない場合、バリデータをリストの中に置いてください。
If you want the field validated, but you do not want a dropbox, you must put the validator in a list.

``
db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]
``:code

``_and``:inxx
場合によっては、ドロップボックスは使用したい(上のようにはリスト構文を用いたくない)が、追加のバリデータを使用したいときがあります。この目的のために、``IS_IN_DB``バリデータは``_and``という追加の引数をとります。これは、検証値が``IS_IN_DB``の検証を通った場合に適用される他のバリデータのリストを指します。たとえば、db内のすべてのdogのownersにおいて、あるサブセットにはないことを検証するためには次のようにします：
Occasionally you want the drop-box (so you do not want to use the list syntax above) yet you want to use additional validators. For this purpose the ``IS_IN_DB`` validator takes an extra argument ``_and`` that can point to a list of other validators applied if the validated value passes the ``IS_IN_DB`` validation. For example to validate all dog owners in db that are not in a subset:
``
subset=db(db.person.id>100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset,'person.id'))
``:code

``IS_IN_DB``はselectの``cache``引数と同じような``cache``引数も取ります。
``IS_IN_DB`` also takes a ``cache`` argument that works like the ``cache`` argument of select.

##### ``IS_IN_DB``とタグ付け
``tags``:inxx
``multiple``:inxx

``IS_IN_DB``バリデータは、``multiple=False``というオプション属性を持ちます。これが``True``に設定されている場合、複数の値が1つのフィールドに保存されます。このフィールドは、第6章で説明した``list:reference``型にする必要があります。そこでは、明示的なタグ付けの例が説明されています。``multiple``の参照は作成と更新フォームにおいて自動的に処理されます。しかし、DALに対して透過的ではありません。multipleフィールドをレンダリングするためには、jQueryのmultiselectプラグインを使用することを強く勧めます。
The ``IS_IN_DB`` validator has an optional attribute ``multiple=False``. If set to ``True`` multiple values can be stored in one field. This field should be of type ``list:reference`` as discussed in Chapter 6. An explicit example of tagging is discussed there. ``multiple`` references are handled automatically in create and update forms, but they are transparent to the DAL. We strongly suggest using the jQuery multiselect plugin to render multiple fields.

#### カスタムバリデータ
``custom validator``:inxx

すべてのバリデータは、以下のプロトタイプに従っています：
All validators follow the prototype below:
``
class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(self, value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)
``:code

すなわち、値を検証するために呼ばれたとき、バリデータは``(x, y)``というタプルを返します。``y``が``None``の場合、値は検証を通過し、``x``は通過した値を保持します。たとえば、バリデータが値に整数であることを要求する場合、``x``は``int(value)``に変換されます。値が検証を通過しない場合は、``x``は入力値を保持し、``y``は検証の失敗を説明するエラーメッセージを保持します。このエラーメッセージは、値が妥当でないフォームにエラーを報告するために使用されます。
i.e., when called to validate a value, a validator returns a tuple ``(x, y)``. If ``y`` is ``None``, then the value passed validation and ``x`` contains a parsed value. For example, if the validator requires the value to be an integer, ``x`` is converted to ``int(value)``. If the value did not pass validation, then ``x`` contains the input value and ``y`` contains an error message that explains the failed validation. This error message is used to report the error in forms that do not validate.

バリデータは``formatter``メソッドも持つことが可能です。これは、``__call__``が行うものと逆の変換を行う必要があります。たとえば、``IS_DATE``に対するソースコードを考えてみます：
The validator may also contain a ``formatter`` method. It must perform the opposite conversion to the one the ``__call__`` does. For example, consider the source code for ``IS_DATE``:
``
class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))
``:code

成功した場合、 ``__call__``メソッドはフォームからデータ文字列を読み取り、コンストラクタで指定したフォーマット文字列を用いてそれをdatetime.dateオブジェクトに変換します。``formatter``オブジェクトは、datetime.dateオブジェクトを受け取り、同じフォーマットを用いてそれを文字列表現に変換します。``formatter``はフォームによって自動的に呼び出されます。しかし、明示的に使用して、オブジェクトを適切な表現に変換することもできます。例:
On success, the ``__call__`` method reads a date string from the form and converts it into a datetime.date object using the format string specified in the constructor. The ``formatter`` object takes a datetime.date object and converts it to a string representation using the same format. The ``formatter`` is called automatically in forms, but you can also call it explicitly to convert objects into their proper representation. For example:
``
>>> db = DAL()
>>> db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
>>> id = db.atable.insert(birth=datetime.date(2008, 1, 1))
>>> row = db.atable[id]
>>> print db.atable.formatter(row.birth)
01/01/2008
``:code

複数のバリデータが要求(リストに格納)されたとき、それらは順序通りに実行され、1つの出力は入力として次のものへ渡されます。この連鎖は、バリデータのいずれかが失敗したときに中断されます。
When multiple validators are required (and stored in a list), they are executed in order and the output of one is passed as input to the next. The chain breaks when one of the validators fails.

反対に、フィールドの``formatter``メソッドを呼ぶとき、複数のバリデータに関連付けられたformattersもまた連鎖されますが、逆順になります。
Conversely, when we call the ``formatter`` method of a field, the formatters of the associated validators are also chained, but in reverse order.

------
カスタムバリデータの代わりに``form.accepts(...)``、``form.process(...)``、``form.validate(...)``の要素である``onvalidate``を使用することもできます。
Notice that as alternative to custom validators, you can also use the ``onvalidate`` argument of ``form.accepts(...)``, ``form.process(...)`` and ``form.validate(...)``.
------


#### 依存関係のバリデータ

通常、バリデータは全てのモデル内で一度だけ設定されます。
Usually validators are set once for all in models.

フィールドを検証する必要があり、その検証が別のフィールドの値に依存することがあります。これはいろいろな方法で実現できます。モデルで実現する方法とコントローラで実現する方法があります。
Occasionally, you need to validate a field and the validator depends on the value of another field. This can be done in various ways. It can be done in the model or in the controller.

例として、ユーザー名と2度のパスワードを尋ねる登録フォームを生成するページを示します。どのフィールドも空にすることはできず、両者のパスワードは一致しなければなりません：
For example, here is a page that generates a registration form that asks for username and password twice. None of the fields can be empty, and both passwords must match:
``
def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_EQUAL_TO(request.vars.password)))
    if form.process().accepted:
        pass # or take some action
    return dict(form=form)
``:code

同じメカニズムは、FORMとSQLFORMオブジェクトに適用することができます。
The same mechanism can be applied to FORM and SQLFORM objects.

### Widgets

以下に利用可能なweb2pyのウィジェットの一覧を示します：
Here is a list of available web2py widgets:
``
SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete
``:code

最初の10個は対応するフィールド型のデフォルトになります。"options"ウィジェットは、フィールドの要求が``IS_IN_SET``か``IS_IN_DB``で``multiple=False``(デフォルトの挙動)のときに使用されます。"multiple"ウィジェットはフィールドの要求が``IS_IN_SET``か``IS_IN_DB``で``multiple=True``のときに使用されます。"radio"と"checkboxes"ウィジェットはデフォルトでは決して使用されませんが、手動で設定することができます。autocompleteウィジェットは特別で、それ自身のセクションで説明します。
The first ten of them are the defaults for the corresponding field types. The "options" widget is used when a field's requires is ``IS_IN_SET`` or ``IS_IN_DB`` with ``multiple=False`` (default behavior). The "multiple" widget is used when a field's requires is ``IS_IN_SET`` or ``IS_IN_DB`` with ``multiple=True``. The "radio" and "checkboxes" widgets are never used by default, but can be set manually. The autocomplete widget is special and discussed in its own section.

たとえば、textareaで表示される"文字列"フィールドを持つには以下のようにします：
For example, to have a "string" field represented by a textarea:
``
Field('comment', 'string', widget=SQLFORM.widgets.text.widget)
``:code

ウィジェットをフィールドに''帰納的に''割り当てることもできます:
Widgets can also be assigned to fields ''a posteriori'':

``
db.mytable.myfield.widget = SQLFORM.widgets.string.widget
``

ウィジェットは値が指定される必要がある追加の引数を取る場合があります。この場合、``lambda``を使用できます。
Sometimes widgets take additional arguments and one needs to specify their values. In this case one can use ``lambda``

``
db.mytable.myfield.widget = lambda field,value: \
    SQLFORM.widgets.string.widget(field,value,_style='color:blue')
``

ウィジェットはヘルパファクトリで、最初の2つの引数は常に``field``と``value``です。他の引数には通常のヘルパの属性である``_style``や``_class``等を含みます。特別な引数を取るウィジェットもあります。具体的にいうと、``SQLFORM.widgets.radio``や``SQLFORM.widgets.checkboxes``はそれを格納するフォームの``formstyle``と適合するために、"table"、"ul"、"divs"を指定できる``style``引数（``_style``と混同しないでください）を取ることができます。
Widgets are helper factories and their first two arguments are always ``field`` and ``value``. The other arguments can include normal helper attributes such as ``_style``, ``_class``, etc. Some widgets also take special arguments. In particular ``SQLFORM.widgets.radio`` and ``SQLFORM.widgets.checkboxes`` take a ``style`` argument (not to be confused with ``_style``) which can be set to "table", "ul", or "divs" in order to match the ``formstyle`` of the containing form.

新しいウィジェットを作成したり、既存のウィジェットを拡張したりすることができます。
You can create new widgets or extend existing widgets.

``SQLFORM.widgets[type]``はクラスで、``SQLFORM.widgets[type].widget``は対応するクラスの静的メンバ関数です。各ウィジェット関数は2つの引数をとります。フィールドオブジェクトと現在のフィールドの値です。これは、ウィジェットの表現を返します。例として、stringウィジェットは次のように再コード化することができます：
``SQLFORM.widgets[type]`` is a class and ``SQLFORM.widgets[type].widget`` is a static member function of the corresponding class. Each widget function takes two arguments: the field object, and the current value of that field. It returns a representation of the widget. As an example, the string widget could be recoded as follows:
``
def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field._tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)
``:code

idとclassの値は、本章の後半で説明されている慣例に従う必要があります。ウィジェットは独自のバリデータを持つことが可能ですが、バリデータをフィールドの"requires"属性に関連付け、ウィジェットがそこからそれらを得るようにするのが良いプラクティスです。
The id and class values must follow the convention described later in this chapter. A widget may contain its own validators, but it is good practice to associate the validators to the "requires" attribute of the field and have the widget get them from there.

#### Autocomplete widget
``autocomplete``:inxx

autocompleteウィジェットには2つの使い道があります：リストから値を受けてフィールドを自動補完するためと、参照フィールドを自動補完するためです(ここで自動補完される文字列はidのように実装された参照の表現です)。
There are two possible uses for the autocomplete widget: to autocomplete a field that takes a value from a list or to autocomplete a reference field (where the string to be autocompleted is a representation of the reference which is implemented as an id).

最初のケースは簡単です：
The first case is easy:
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, limitby=(0,10), min_length=2)
``:code

ここで、``limitby``は一度に10個までの候補しか表示しないようにウィジェットに指示します。``min_length``は、ユーザーが検索ボックスにおいて少なくとも2文字をタイプした後のみ、候補を取得するAjaxコールバックを実行するようにウィジェットに指示します。
Where ``limitby`` instructs the widget to display no more than 10 suggestions at the time, and ``min_length`` instructs the widget to perform an Ajax callback to fetch suggestions only after the user has typed at least 2 characters in the search box.

2番目のケースはより複雑になります：
The second case is more complex:
``
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)
``:code

この場合、``id_field``の値は、自動補完される値が``db.category.name``でも、保存される値は対応する``db.category.id``になるようにウィジェットに指示します。オプションのパラメタ``orderby``は、候補をどのようにソートするかをウィジェットに指示します(デフォルトはアルファベット順です)。
In this case the value of ``id_field`` tells the widget that even if the value to be autocompleted is a ``db.category.name``, the value to be stored is the corresponding ``db.category.id``. An optional parameter is ``orderby`` that instructs the widget on how to sort the suggestions (alphabetical by default).

このウィジェットは、Ajaxを介して動作します。ここで、Ajaxコールバックはどこにあるのでしょうか？いくつかの魔法が、このウィジェットで起こっています。コールバックはウィジェットオブジェクトのメソッドそのものです。どのように公開されているのでしょうか？web2pyにおいて、任意のコード断片はHTTP例外を発生させることによってレスポンスを生成することができます。このウィジェットは次の方法でこの可能性を利用しています：ウィジェットはAjax呼び出しを最初にウィジェットを生成したURLと同じところに送ります。そして、request.varsにおいて特別なトークンを置きます。ウィジェットは再びインスタンス化されるはずで、ウィジェットはそのトークンを見つけ、リクエストに応答するHTTP例外を発生させます。これらすべては内部で行われ、開発者に対して隠されています。
This widget works via Ajax. Where is the Ajax callback? Some magic is going on in this widget. The callback is a method of the widget object itself. How is it exposed? In web2py any piece of code can generate a response by raising an HTTP exception. This widget exploits this possibility in the following way: the widget sends the Ajax call to the same URL that generated the widget in the first place and puts a special token in the request.vars. Should the widget get instantiated again, it finds the token and raises an HTTP exception that responds to the request. All of this is done under the hood and hidden to the developer.

### ``SQLFORM.grid``と``SQLFORM.smartgrid`` (実験的)

複雑なCRUDコントロールを作成する2つの高機能なガジェットがあります。レコードのページ送り、表示、検索、ソート、作成、更新、削除を1つのガジェットから実行する機能を提供します。
These are two high level gadgets that create complex CRUD controls. They provide pagination, the ability to browser, search, sort, create, update and delete records from a single gadgets.

``SQLFORM.grid``の方がシンプルです。ここに使用方法の例を挙げます:
The simplest of the two is ``SQLFORM.grid``. Here is an example of usage:

``
@auth.requires_login()
def manage_users():
    grid = SQLFORM.grid(db.auth_user)
    return locals()
``
これは次のページを作成します。
which produces the following page:

[[image @:image/en6700.png center 480px]]

``SQLFORM.grid``の最初の引数はテーブル名かクエリです。gridガジェットはクエリに適合したレコードに対する接続を提供します。
The first argument of ``SQLFORM.grid`` can be a table or a query. The grid gadget will provide access to records matching the query.

gridガジェットの膨大な引数のリストの説明の前に、どのように動作するかを理解する必要があります。ガジェットは``request.args``を参照し何の動作（表示、検索、作成、更新、削除等）をするか決定します。ガジェットで作成されたそれぞれのボタンは同じ関数（上記の場合は``manage_users``）にリンクされますが、異なる``request.args``を渡します。gridによって作成されたURLは全てデフォルトで電子署名され認証されています。これはユーザーがログインしていない場合、一部の機能（作成、更新、削除）が実行できないことを意味します。この制限については緩和することができます。
Before we dive into the long list of arguments of the grid gadget we need to understand how it works. The gadget looks at ``request.args`` in order to decide what to do (browse, search, create, update, delete, etc.). Each button created by the gadget links the same function (``manage_users`` in the above case) but passes different ``request.args``. By default all the URL generated by the grid are digitally signed and verified. This means one cannot perform certain actions (create, update, delete) without being logged-in. These restrictions can be relaxed:

``
def manage_users():
    grid = SQLFORM.grid(db.auth_user,user_signature=False)
    return locals()
``

しかし、これは推奨されません。
but we do not recommend it.

-----
``LOAD``を利用してコンポーネントとして埋め込みでもしない限り、gridはコントローラの関数につきひとつしか使用できないからです。
Because of the way grid works one can only have one grid per controller function, unless they are embedded as components via ``LOAD``.
-----

gridを含む関数自体がコマンドライン引数を操作する場合があるので、gridはどの引数をgridで処理し、どの引数をgrid以外で処理するかを把握する必要があります。例えば、これは任意のテーブルを処理できるコードの例です。
Because the function that contains the grid may itself manipulate the command line arguments, the grid needs to know which args should be handled by the grid and which not. For example here is an example of code that allows one to manage any table:

``
@auth.requires_login()
def manage():
    table = request.args(0)
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.grid(db[table],args=request.args[:1])
    return locals()
``
``grid``の``args``引数はどの``request.args``がガジェットに渡されるか若しくは無視されるかを指定します。私たちの例では``request.args[:1]``は処理したいテーブル名を表し、ガジェットではなく、``manage``関数自体で扱われています。
the ``args`` argument of the ``grid`` specifies which ``request.args`` should be passed along and ignored by the gadget. In our case ``request.args[:1]`` is the name of the table we want to manage and it is handled by the ``manage`` function itself, not by the gadget.

gridの完全な用法は次のようになります:
The complete signature for the grid is the following:

``
SQLFORM.grid(query,
             fields=None,
             field_id=None,
             left=None,
             headers={},
             orderby=None,
             searchable=True,
             sortable=True,
             deletable=True,
             editable=True,
             details=True,
             create=True,
             csv=True,
             paginate=20,
             selectable=None,
             links=None,
             upload = '<default>',
             args=[],
             user_signature = True,
             maxtextlengths={},
             maxtextlength=20,
             onvalidation=None,
             oncreate=None,
             onupdate=None,
             ondelete=None,
             sorter_icons=('[^]','[v]'),
             ui = 'web2py',
             showbuttontext=True,
             search_widget='default',
             _class="web2py_grid",
             formname='web2py_grid',
             ignore_rw = False,
             formstyle = 'table3cols'):
``:code

- ``fields`` はデータベースから取得されるフィールドのリストです。gridビューにどのフィールドを表示するかを決定するためにも使用されます。
- ``fields`` is a list of fields to be fetched from the database. It is also used to determine which fields to be shown in the grid view.
- ``field_id`` は``db.mytable.id``のように、IDとして使用されるテーブルのフィールドである必要があります。
- ``field_id`` must be the field of the table to be used as ID, for example ``db.mytable.id``.
- ``headers`` は'tablename.fieldname'を対応するヘッダーラベルにマッピングする辞書です。
- ``headers`` is a dictionary that maps 'tablename.fieldname' into the corresponding header label.
- ``left`` は``...select(left=...)``によって左外部結合を定義したい場合に利用する追加の記述です。
- ``left`` is an optional left join expressions used to build ``...select(left=...)``.
- ``orderby`` はrowsのデフォルトでの表示順序に使用します。
- ``orderby`` is used as default ordering for the rows.
- ``searchable``,``sortable``, ``deletable``, ``details``, ``create`` は検索、ソート、削除、詳細表示、新規レコード作成を実行できるかどうかそれぞれ決定します。
- ``searchable``, ``sortable``, ``deletable``, ``details``, ``create`` determine whether one can search, sort, delete, view details, and create new records respectively.
- ``csv`` trueの場合はCSV形式でgridをダウンロードできます。
- ``csv`` if set to true allows to download the grid in CSV.
- ``paginate`` は各ページのrowsの最大値を指定します。
- ``paginate`` sets the max number of rows per page.
- ``links`` は異なるページにリンクできる新しい項目を表示するのに使用されます。``links``変数は``dict(header='name',body=lambda row: A(...))``のリストを取る必要があります。``header``は新しい項目のヘッダーで、``body``はrowを取得し値を返します。この例でいうとその値は``A(...)``ヘルパになります。
- ``links`` is used to display new columns which can be links to other pages. The ``links`` argument must be a list of  ``dict(header='name',body=lambda row: A(...))`` where ``header`` is the header of the new column and ``body`` is a function that takes a row and returns a value. In the example, the value is a ``A(...)`` helper.
- ``maxtextlength`` はgridビュー上で表示される各フィールドの文字の最大長を設定します。この値は'tablename.fieldname':lengthの辞書として``maxtextlengths``を利用し上書くことができます。
- ``maxtextlength`` sets the maximum length of text to be displayed for each field value, in the grid view. This value can be overwritten for each field using ``maxtextlengths``, a dictionary of 'tablename.fieldname':length.
- ``onvalidation``, ``oncreate``, ``onupdate``,``ondelete`` はコールバック関数です。``ondelete``はフォームオブジェクトを入力値として受け取ります。
- ``onvalidation``, ``oncreate``, ``onupdate`` and ``ondelete`` are callback functions. All but ``ondelete`` take a form object as input.
- ``sorter_icons`` は各フィールドの昇順、降順ソートオプションを表示するふたつの文字（またはヘルパ）のリストです。
- ``sorter_icons`` is a list of two strings (or helpers) that will be used to represent the up and down sorting options for each field.

- ``ui`` は'web2py'と同様にweb2py形式のクラス名を設定します。``jquery-ui``はjquery UI形式のクラス名を設定しますが、様々なgridコンポーネントにおいて独自のクラスも設定されます。
- ``ui`` can be set equal to 'web2py' and will generate web2py friendly class names, can be set equal to ``jquery-ui`` and will generate jquery UI friendly class names, but it can also be its own set of class names for the various grid components:

``
ui = dict(widget='',
          header='',
          content='',
          default='',
          cornerall='',
          cornertop='',
          cornerbottom='',
          button='button',
          buttontext='buttontext button',
          buttonadd='icon plus',
          buttonback='icon leftarrow',
          buttonexport='icon downarrow',
          buttondelete='icon trash',
          buttonedit='icon pen',
          buttontable='icon rightarrow',
          buttonview='icon magnifier')
``:code

- ``search_widget`` はデフォルトの検索ウィジェットを上書くことができます。詳細は"gluon/sqlhtml.py"のソースコードを参照してください。
- ``search_widget`` allows to override the default search widget and we refer the reader the source code in "gluon/sqlhtml.py" for details.
- ``showbutton`` 全てのボタンを非表示にできます。
- ``showbutton`` allows to turn off all buttons.
- ``_class`` はgridコンテナのクラスです。
- ``_class`` is the class for the grid container.
- ``formname``, ``ignore_rw``, ``formstyle`` は作成/更新フォーム用のgridで使用されるSQLFORMオブジェクトに渡されます。
- ``formname``, ``ignore_rw`` and ``formstyle`` are passed to the SQLFORM objects used by the grid for create/update forms.

------
``deletable``, ``editable``, ``details`` は一般的にブーリアンの値ですが、rowオブジェクトを取得し対応するボタンを表示・非表示するか決定するといった関数も使用できます。
``deletable``, ``editable`` and ``details`` are usually boolean values but they can be functions which take the row object and decide whether to display the corrsponding button or not.
-----
``SQLFORM.smartgrid``は``grid``に非常によく似ています。実際にgridを含みますが、クエリではなくひとつのテーブルを入力として受け取るように設計されています。そして参照先のテーブルも表示します。
A ``SQLFORM.smartgrid`` looks a lot like a ``grid``, in fact it contains a grid but it is designed to take as input not a query but only one table and to browse said table and selected referencing tables.

以下のテーブル構造を考えてみましょう:
For example consider the following table structure:

``
db.define_table('parent',Field('name'))
db.define_table('child',Field('name'),Field('parent','reference parent'))
``:code

SQLFORM.gridで全ての親を一覧表示できます:
With SQLFORM.grid you can list all parents:

``
SQLFORM.grid(db.parent)
``:code
全ての子供:
all children:
``
SQLFORM.grid(db.child)
``:code
全ての親と子供をひとつのテーブル:
and all parents and children in one table:
``
SQLFORM.grid(db.parent,left=db.child.on(db.child.parent=db.parent.id))
``:code

SQLFORM.smartgridで全てのデータをまとめたひとつのガジェットを作成し、両方のテーブルを出力できます。
With SQLFORM.smartgrid you can put all the data in one gadget that spawns both tables:

``
@auth.requires_login():
def manage():
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
``:code

以下のようになります:
which looks like this:

[[image @:image/en6800.png center 480px]]

"children"リンクが追加されています。通常の``grid``を利用して追加の``links``を作成することもできますがその場合は異なる機能を示しています。``smartgrid``を利用することで自動的に作成され同じガジェットで処理されます。
Notice the extra "children" links. One could create the extra ``links`` using a regular ``grid`` but they would point to a different action. With a ``smartgrid`` they are created automatically and handled by the same gadget.

また、ある親の"children"リンクをクリックするとその親に紐づく（これは明らかですが）子供だけのリストが取得できます。しかし、新しい子供を追加しようとすると、その子供の親の値は選択された親（ガジェットに関連るパンくずリストで表示）から自動的に設定されます。そのフィールドの親の値は上書くこともできます。読み取り専用にすることで上書きを防げます。
Also notice that when clicking on the "children" link for a given parent one only gets the list of children for that parent (and that is obvious) but also notice that if one now tried to add a new child, the parent value for the new child is automatically set to the selected parent (displayed in the breadcrumbs associated to the gadget). The value of this field can be overwritten. We can prevent this by making it readonly:

``
@auth.requires_login():
def manage():
    db.child.parent.writable = False
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
``:code

``linked_tables``引数が指定されていない場合は全ての参照テーブルが自動的にリンクされます。どちらにせよ、誤ってデータが公開されないように、リンクされるべきテーブルの一覧を明示的に指定することを推奨します。
If the ``linked_tables`` argument is not specified all referencing tables are automatically linked. Anyway, to avoid accidentally exposing data we recommend explicitly listing tables that should be linked.

次のコードはシステム内の全てのテーブルの非常に強力な管理インターフェースを作成します。
The following code creates a very powerful management interface for all tables in the system:

``
@auth.requires_membership('managers'):
def manage():
    table = request.args(0) or 'auth_user'
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.smartgrid(db[table],args=request.args[:1])
    return locals()
``:code

 `smartgrid``は``grid``と同じ引数を取り、条件付で追加の引数も取ります。
The ``smartgrid`` takes the same arguments as a ``grid`` and some more with some caveats:

- 最初の引数はテーブルで、クエリではありません
- The first argument is a table, not a query
- 'tablename':queryの辞書である``constraints``という追加の引数があります。これは'tablename'gridで表示されるレコードに対してさらなるアクセス制限をかけることができます。
- There is a extra argument ``constraints`` which is a dictionary of 'tablename':query which can be used to further restrict access to the records displayed in the 'tablename' grid.
- smartgridから接続できるテーブルの名称リストである``linked_tables``という追加の引数があります。
- There is a extra argument ``linked_tables`` which is a list of tablenames of tables that should be accessible via the smartgrid.
- 以下で説明するようにテーブル、``args``、``linked_tables``、``user_signatures``に辞書型を使うことができます。
- All the arguments but the table, ``args``, ``linked_tables`` and ``user_signatures`` can be dictionaries as explained below.

前回のgridを考えて見ましょう:
Consider the previous grid:
``
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
``

``db.parent``と``db.child``の両方に接続できます。ナビゲーションコントロールにとって、それぞれのテーブルは、スマートテーブルではなくただのgridです。この場合、これはひとつのsmartgridが親と子供のgridをひとつずつ作成できることを意味します。これらのgridに異なるパラメタのセットを渡すこともできます。例えば異なる``searchable``パラメタのセットです。
It allows one to access both a ``db.parent`` and a ``db.child``. Apart for navigation controls, for each one table, a smarttable is nothing but a grid. This means that, in this case, one smartgrid can create a grid for parent and one grid for child. We may want to pass different sets of parameters to these grids. For example different sets of ``searchable`` parameters.

gridではブーリアン型を渡せます:
While for a grid we would pass a boolean:
``
grid = SQLFORM.grid(db.parent,searchable=True)
``
smartgridではブーリアン型の辞書を渡せます:
for a smartgrid we would pass a dictionary of booleans:
``
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'],
     searchable= dict(parent=True, child=False))
``
このように親は検索可能だが子供は検索不可（検索ウィジェットが必要な場合はあまり多くないです）にできます。
In this way we made parents searchable but children for each parent not searchable (there should not be that many to need the search widget).


-------
gridとsmartgridは今後も残りますが実験的としています。これは新たな機能追加があった場合に、返される実際のhtmlレイアウトやパラメータのセットが変更される可能性があるからです。
The grid and smartgrid gadgets are here to stay but they are marked experimental because the actual html layout of what they return and the exact set of parameters one can pass to them  may be subject to change as new functionalities are added.
-------


``grid``と``smartgrid``はcrudのように自動でアクセス権を強制しませんが、``auth``と統合して明示的にパーミッションを確認することができます:
``grid`` and ``smartgrid`` do not automatically enforce access control like crud does but you can integrate it with ``auth`` using explicit permission checking:

``
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_membership('managers'),
     deletable = auth.has_membership('managers'))
``

または
or

``
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_permission('edit','auth_user'),
     deletable = auth.has_permission('delete','auth_user'))
``

``smartgrid``は単数形と複数形の両方のテーブル名を表示する唯一のweb2pyのガジェットです。例えばparentは一人の"Child"や、たくさんの"Children"を持てます。それゆえ、テーブルオブジェクトは自身の単数形と複数形の名称を知る必要があります。web2pyは通常これを予測しますが明示的に設定することもできます:
The ``smartgrid`` is the only gadget in web2py that displays the table name and it need both the singular and the plural. For example one parent can have one "Child" or many "Children". Therefore a table object needs to know its own singular and plural names. web2py normally guesses them but you can set the explicitly:

``
db.define_table('child', ..., singular="Child", plural="Children")
``:code

または: ``singular``:inxx ``plural``:inxx
or with: ``singular``:inxx ``plural``:inxx

``
db.define_table('child', ...)
db.child._singular = "Child"
db.child._plural = "Children"
``:code

``T``演算子を使用して国際化対応することもできます。
They should also be internationalized using the ``T`` operator.

そして複数形と単数形の値は``smartgrid``で使用されるヘッダーとリンクの正しい名前として提供されます；。
The plural and singular values are then used by ``smartgrid`` to provide correct names for headers and links.

##### 第3版 - 翻訳: 細田謙二　レビュー: Omi Chiba
##### 第4版 - 翻訳: Omi Chiba　レビュー: Fumito Mizuno
